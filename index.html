<!DOCTYPE html>
<!--
```PLAN.md
Stack: Single-file HTML5 game. Primary renderer: Canvas2D with adapter shim; WebGL2 path detected with safe fallback. Saves: ap-save-v2 (progress), ap-meta (map). Input/UI unchanged.

Patches timeline:
- Patch 1 ‚Äî Adapter, flags, safe fallback
  - Add GRAPHICS flags/localStorage key `ap-graphics`.
  - Introduce Renderer adapter with stage hooks and WebGL2 detection; fallback to Canvas path. Keep stage order.
  - FPS safeguard hooks prepared for adaptive quality.

- Patch 2 ‚Äî Camera + depth sorting + NPC sprites
  - Add procedural sprite atlas for NPCs (sign, merchant, trainer, storage, cart master, cart, harbor/ferry).
  - Replace icon badges with animated sprites, same hitboxes; depth-sort by screen Y.
  - Add TTS (Alt+T toggle, localStorage `ap-tts`) and Merchant greeting when opening shop.

Later patches (not in this edit):
- Patch 3 ‚Äî Lighting baseline + blob shadows / shadowmap
- Patch 4 ‚Äî Butterflies (ambient boids)
- Patch 5 ‚Äî Zant maps + portals (no ferry to Canyon)
- Patch 6 ‚Äî Flaenae upgrade (snare + pollen)
- Patch 7 ‚Äî Polish & post-fx
- Patch 8 ‚Äî Minimap + UI sync
```
-->
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />
<title>Adventure Plains ‚Äî Mini ROSE-like (v3)</title>
<style>
  :root{
    --ui-bg: rgba(18,22,28,0.85);
    --ui-accent: #6cf;
    --hp: #e74c3c;
    --mp: #3498db;
    --xp: #9b59b6;
    --gold: #f1c40f;
    --green: #71e6a2;
  }
  html, body{ margin:0; height:100%; background:#0a0f14; color:#e6eef7; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans", "Apple Color Emoji", "Segoe UI Emoji"; overflow:hidden; }
  #game-wrap{position:fixed; inset:0; display:grid; grid-template-rows: 1fr auto;}
  canvas{width:100%; height:100%; display:block; background: radial-gradient(200vmax 200vmax at 30% 30%, #10212e, #0a0f14 60%);} 

  /* HUD */
  .hud{position:fixed; inset:0; pointer-events:none;}
  .bar{position:absolute; left:12px; top:12px; width:min(640px, 94vw); background:var(--ui-bg); padding:10px; border-radius:14px; box-shadow:0 10px 30px rgba(0,0,0,.35);} 
  .row{display:flex; gap:8px; align-items:center;}
  .chip{padding:2px 8px; border-radius:999px; background:rgba(255,255,255,.06); font-size:12px;}
  .meter{position:relative; height:10px; flex:1; background:rgba(255,255,255,.08); border-radius:999px; overflow:hidden}
  .meter>i{position:absolute; inset:0; width:0%; display:block}
  .hp{background:linear-gradient(90deg, var(--hp), #ff7675)}
  .mp{background:linear-gradient(90deg, var(--mp), #6ab3ff)}
  .xp{background:linear-gradient(90deg, var(--xp), #cfa2ff)}

  /* Buff icons bar */
  .buffbar{display:flex; gap:6px; align-items:center; margin:6px 0 2px}
  .buff{display:inline-flex; align-items:center; justify-content:center; width:22px; height:22px; border-radius:6px; background:rgba(255,255,255,.07); border:1px solid rgba(255,255,255,.12); font-size:14px}
  .buff[title]{cursor:help}

  .xpbar{position:absolute; left:50%; transform:translateX(-50%); bottom:16px; width:min(860px, 96vw); background:var(--ui-bg); padding:10px 12px; border-radius:14px; pointer-events:none}

  .quest{position:absolute; right:12px; top:12px; background:var(--ui-bg); padding:10px 12px; border-radius:14px; width:min(420px, 96vw);} 
  /* Minimap */
  .minimap{position:absolute; left:12px; top:110px; width:180px; height:120px; background:var(--ui-bg); border-radius:10px; box-shadow:0 6px 20px rgba(0,0,0,.25); pointer-events:none;}
  .minimap-label{position:absolute; left:12px; top:236px; background:var(--ui-bg); border:1px solid rgba(255,255,255,.12); padding:4px 8px; border-radius:10px; font-size:12px;}
  .quest h3{margin:0 0 4px 0; font-size:14px; letter-spacing:.3px}
  .quest p{margin:2px 0; font-size:13px; color:#cde}

  .hint{position:absolute; left:50%; transform:translateX(-50%); top:12px; background:var(--ui-bg); padding:6px 10px; border-radius:12px; border:1px solid rgba(255,255,255,.12); font-size:12px;}

  /* Windows */
  .window{position:fixed; right:12px; bottom:70px; width:min(640px, 96vw); background:#0f1520; border:1px solid rgba(255,255,255,.12); border-radius:16px; box-shadow:0 20px 60px rgba(0,0,0,.45); padding:14px; display:none; pointer-events:auto;}
  .window h2{margin:2px 0 8px; font-size:16px}
  .window .list{display:grid; grid-template-columns: 1fr auto; gap:10px; max-height: 54vh; overflow:auto;}
  .window .item{background:rgba(255,255,255,.05); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px}
  .window button{all:unset; background:linear-gradient(180deg, #1d2b3a, #13202c); border:1px solid rgba(255,255,255,.18); padding:8px 10px; border-radius:10px; cursor:pointer;}
  .window .close{position:absolute; right:10px; top:10px; opacity:.8}
  .pill{display:inline-block; padding:2px 8px; border-radius:999px; background:rgba(255,255,255,.08); font-size:11px; margin-left:6px}

  /* Item icons */
  .icon{width:48px; height:48px; display:inline-grid; place-items:center; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12); border-radius:10px; margin-right:10px}
  .icon svg{width:38px; height:38px; display:block}
  /* Gold chip emphasis */
  .hud .chip span#gold{ font-size:1.15em; font-weight:700; text-shadow:0 0 6px rgba(241,196,15,0.55), 0 0 14px rgba(241,196,15,0.35); }

  /* Character window */
  #charWin .grid{display:grid; grid-template-columns: 1fr 1fr; gap:10px}
  #charWin .paper{background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:10px}
  #charWin .slots{display:grid; grid-template-columns: repeat(2, minmax(0,1fr)); gap:8px}
  #charWin .slotrow{display:flex; align-items:center; gap:8px; background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08); border-radius:10px; padding:6px}
  #charWin .stats{display:grid; grid-template-columns: 1fr 1fr; gap:6px}

  /* Skills hotbar */
  .hotbar{position:absolute; left:50%; transform:translateX(-50%); bottom:70px; display:flex; gap:8px; pointer-events:auto}
  .slot{width:64px; height:64px; border-radius:12px; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.14); display:grid; place-items:center; position:relative; font-size:24px}
  .slot b{position:absolute; left:6px; top:4px; font-size:11px; opacity:.7}
  .hotbar .slot svg{width:36px; height:36px; display:block}
  .cd{position:absolute; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; border-radius:10px; font-size:12px}

  /* Touch controls */
  .touch{position:fixed; inset:0; display:none;}
  .stick{position:absolute; left:18px; bottom:18px; width:120px; height:120px; border-radius:50%; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.12);} 
  .knob{position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); width:68px; height:68px; border-radius:50%; background:rgba(255,255,255,.15); border:1px solid rgba(255,255,255,.25);} 
  .btn{position:absolute; right:20px; bottom:24px; width:88px; height:88px; border-radius:50%; background:rgba(255,255,255,.08); border:1px solid rgba(255,255,255,.18); display:grid; place-items:center;} 
  .btn::after{content:'‚öîÔ∏è'; filter:drop-shadow(0 2px 4px rgba(0,0,0,.6)); font-size:28px}
  @media (pointer:coarse){ .touch{display:block} }

  /* Overlay (main menu) */
  .overlay{position:fixed; inset:0; background:rgba(5,8,12,.72); display:grid; place-items:center;} 
  .panel{width:min(820px, 96vw); background:#0e141c; border:1px solid rgba(255,255,255,.08); border-radius:18px; box-shadow:0 30px 80px rgba(0,0,0,.5); padding:20px 18px}
  .panel h1{margin:.2em 0 .1em; letter-spacing:.3px}
  .panel p{color:#cfe}
  .panel .actions{display:flex; gap:12px; flex-wrap:wrap}
  .panel button{all:unset; background:linear-gradient(180deg, #1d2b3a, #13202c); border:1px solid rgba(255,255,255,.14); padding:10px 14px; border-radius:12px; cursor:pointer}
  .panel button.primary{background:linear-gradient(180deg, #1e3a5f, #11263d); color:#dff; border-color:#3e6aa1}
  .panel small{color:#9fb; opacity:.85}

  .toast{position:fixed; left:50%; transform:translateX(-50%); top:12px; background:var(--ui-bg); padding:8px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.12); display:none}

  /* Character Creation */
  .cc-grid{display:grid; grid-template-columns: 1fr 1fr; gap:14px}
  .cc-field{display:flex; flex-direction:column; gap:6px}
  .swatch{display:none}

  /* Restyled inputs and dropdowns for visibility */
  .cc-field input[type="text"],
  .cc-field select{
    all:unset;
    background:linear-gradient(180deg, #1a2532, #121a24);
    border:1px solid rgba(255,255,255,.18);
    padding:8px 10px;
    border-radius:10px;
    color:#e6f2ff;
    cursor:text;
  }
  .cc-field select{ cursor:pointer; }
  .cc-field select{ appearance:auto; -webkit-appearance:auto; -moz-appearance:auto; padding-right:26px; }
  /* Ensure dropdown options are readable when list opens (Windows/Chrome) */
  #create select option{ color:#0e141c; background:#ffffff; }

  /* Treehouse-themed panels */
  #create .panel{
    position:relative; overflow:hidden;
    background:linear-gradient(180deg, #0e141c, #0b1119);
  }
  #create .panel::before{
    content:''; position:absolute; inset:0; pointer-events:none;
    background:
      radial-gradient(900px 420px at 15% -10%, rgba(80,130,90,.18), transparent 60%),
      radial-gradient(700px 360px at 110% 110%, rgba(165,120,60,.18), transparent 60%);
  }
  /* Character preview inside creator */
  .cc-preview-wrap{ background:rgba(255,255,255,.04); border:1px solid rgba(255,255,255,.08); border-radius:12px; padding:8px; display:grid; place-items:center; }
  #cc-preview{ width:100%; max-width:360px; aspect-ratio:1; background: radial-gradient(220px 140px at 50% 75%, rgba(0,0,0,0.35), rgba(0,0,0,0) 70%), linear-gradient(180deg, #0a0f14 55%, #5b3b22 55% 58%, #2e1d12 100%); border-radius:10px; }
</style>
</head>
<body>
<div id="game-wrap">
  <canvas id="game"></canvas>

  <div class="hud">
    <div class="bar" aria-label="stats">
      <div class="row" style="gap:12px">
        <div class="chip" id="zone">Adventure Plains</div>
        <div class="chip">Job <span id="job">Visitor</span></div>
        <div class="chip">Name <span id="pname">‚Äî</span></div>
        <div class="chip">LV <span id="lv">1</span></div>
        <div class="chip">Gold <span id="gold">0</span> ‚ú¶</div>
        <div class="chip" id="mountChip" style="display:none">Cart üöó</div>
      </div>
      <div class="buffbar" id="buffbar" aria-label="active buffs"></div>
      <div class="row" style="margin-top:8px">
        <span style="width:42px; font-size:12px">HP</span>
        <div class="meter"><i class="hp" id="hp"></i></div>
        <span style="width:42px; font-size:12px">MP</span>
        <div class="meter"><i class="mp" id="mp"></i></div>
      </div>
    </div>

    <canvas id="minimap" class="minimap"></canvas>
    <div id="minimapLabel" class="minimap-label"></div>

    <div class="quest" aria-live="polite">
      <h3>Quest Tracker</h3>
      <p id="quest-line">Welcome to Adventure Plains. Press <b>E</b> near the signpost.</p>
      <p id="quest-progress"></p>
      <p id="quest-reward" style="opacity:.9"></p>
    </div>

    <div class="hotbar" id="hotbar" aria-label="skills">
      <div class="slot" data-s="0" title="Skill 1"><b>1</b><span id="sicon0">‚Äî</span><div class="cd" id="scd0"></div></div>
      <div class="slot" data-s="1" title="Locked until Lv 10"><b>2</b><span id="sicon1">‚Äî</span><div class="cd" id="scd1"></div></div>
      <div class="slot" data-s="2"><b>3</b><span id="sicon2">‚Äî</span><div class="cd" id="scd2"></div></div>
      <div class="slot" data-s="3"><b>4</b><span id="sicon3">‚Äî</span><div class="cd" id="scd3"></div></div>
    </div>

    <div class="xpbar">
      <div class="row">
        <span style="width:60px; font-size:12px">XP</span>
        <div class="meter"><i class="xp" id="xp"></i></div>
        <span class="chip">Next <span id="nextxp">50</span></span>
         <span class="chip" style="margin-left:auto">Keys: <b>I</b> Inventory ¬∑ <b>Alt+M</b> Shop ¬∑ <b>Alt+L</b> Storage ¬∑ <b>J</b> Jobs ¬∑ <b>Alt+J</b> Job Guide ¬∑ <b>Alt+A</b> Stats/Skills ¬∑ <b>Alt+C</b> Character</span>
      </div>
    </div>

    <div class="hint" id="hint">Find the <b>Merchant</b> (üõí), the <b>Trainer</b> (‚òÖ), and the <b>Cart Master</b> (üõû). Press <b>E</b> to interact.</div>
  </div>

  <div class="touch" aria-hidden="true">
    <div class="stick" id="stick"><div class="knob" id="knob"></div></div>
    <div class="btn" id="atk"></div>
  </div>

  <div class="overlay" id="overlay">
    <div class="panel">
      <h1>Adventure Plains ‚Äî Mini ROSE-like</h1>
      <p>Level to <b>10</b>, choose a <b>Job</b>, learn <b>Skills</b>, earn weapons from <b>Quests</b>, and unlock your <b>Cart License</b> via the Cart Master. Keyboard: <b>WASD/Arrows</b> to move, <b>Mouse/Space</b> to attack, <b>E</b> to interact, <b>I</b> Inventory, <b>M</b> Shop (near Merchant), <b>J</b> Jobs, <b>1‚Äì4</b> skills. Progress auto-saves.</p>
      <div class="actions">
        <button class="primary" id="newgame">New Game</button>
        <button id="continue">Continue</button>
        <button id="erase">Delete Save</button>
      </div>
      <p style="margin-top:10px"><small>Fan-made demake inspired by ROSE Online. No original assets used.</small></p>
    </div>
  </div>

  <!-- Character Creation Overlay -->
  <div class="overlay" id="create" style="display:none">
    <div class="panel">
      <h2>Create Your Rosarian</h2>
      <div class="cc-grid">
        <div>
          <div class="cc-field">
            <label for="cc-name">Name</label>
            <input id="cc-name" type="text" maxlength="16" placeholder="Enter a name" style="all:unset; background:rgba(255,255,255,.06); border:1px solid rgba(255,255,255,.14); padding:8px 10px; border-radius:10px" />
          </div>
          <div class="cc-field">
            <label for="cc-outfit">Outfit Color</label>
            <input id="cc-outfit" type="color" value="#2a6aa8" />
          </div>
          <div class="cc-field">
            <label for="cc-hair">Hair Color</label>
            <input id="cc-hair" type="color" value="#3a2a1a" />
          </div>
          <div class="cc-field">
            <label for="cc-skin">Skin Tone</label>
            <input id="cc-skin" type="color" value="#f2d6c2" />
          </div>
           <div class="cc-field">
            <label for="cc-wings">Wings Style</label>
            <select id="cc-wings">
              <option value="butterfly">Butterfly</option>
              <option value="angel">Angel</option>
              <option value="bat">Bat</option>
              <option value="feather">Feathered</option>
              <option value="mechanical">Mechanical</option>
              <option value="fairy">Fairy</option>
              <option value="none">None</option>
            </select>
          </div>
          <div class="cc-field">
            <label for="cc-weapon">Starting Weapon</label>
            <select id="cc-weapon">
              <option value="wood_sword">One-handed Sword</option>
              <option value="wood_sword_shield">One-handed Sword + Shield</option>
              <option value="wood_2h_sword">Two-handed Sword</option>
              <option value="wood_wand">Wand</option>
              <option value="wood_staff">Staff</option>
              <option value="wood_bow">Bow</option>
              <option value="wood_katar">Katar</option>
              <option value="wood_gun">Gun</option>
              <option value="rocket_launcher">Launcher</option>
            </select>
          </div>
        </div>
        <div>
          <div class="cc-preview-wrap">
            <canvas id="cc-preview"></canvas>
          </div>
          <p style="opacity:.85; margin-top:8px">Tip: You can change gear and wings later. Your name can be changed from the Character window.</p>
        </div>
      </div>
      <div class="actions" style="margin-top:12px">
        <button id="cc-back">Back</button>
        <button class="primary" id="cc-start">Start Adventure</button>
      </div>
    </div>
  </div>

  <!-- Character Select overlay removed per request -->

  <div class="window" id="invWin">
    <button class="close" id="invClose">‚úï</button>
    <h2>Inventory <span class="pill" id="invCount"></span></h2>
      <div class="row" style="gap:6px; margin-bottom:6px; flex-wrap:wrap">
        <div class="chip">Weapon: <span id="eqWeapon">‚Äî</span></div>
        <div class="chip">Helmet: <span id="eqHelmet">‚Äî</span></div>
        <div class="chip">Armor: <span id="eqArmor">‚Äî</span></div>
        <div class="chip">Boots: <span id="eqBoots">‚Äî</span></div>
        <div class="chip">Accessory: <span id="eqAcc">‚Äî</span></div>
        <div class="chip">Wings: <span id="eqWings">‚Äî</span></div>
      </div>
    <div class="list" id="invList"></div>
  </div>

  <div class="window" id="shopWin">
    <button class="close" id="shopClose">‚úï</button>
    <h2>Merchant üõí ‚Äî <span id="shopMapLabel">Region</span> <span class="pill">Gold <span id="shopGold">0</span> ‚ú¶</span></h2>
    <div class="list" id="shopList"></div>
    <p style="opacity:.8; margin-top:8px">Tip: Quests pay <b>Gold</b> ‚Äî spend it at the <b>Merchant</b>. Finish the <b>Cart License</b> quest to ride.</p>
  </div>

  <div class="window" id="jobWin">
    <button class="close" id="jobClose">‚úï</button>
    <h2>Trainer ‚òÖ ‚Äî Choose Your Job <span class="pill">Requires Lv 10</span></h2>
    <div class="list" id="jobList"></div>
  </div>

  <div class="window" id="statsWin">
    <button class="close" id="statsClose">‚úï</button>
    <h2>Stats / Skills <span class="pill">Alt+A or Alt+S</span></h2>
    <div class="list" id="statsList"></div>
  </div>

  <div class="window" id="storageWin">
    <button class="close" id="storageClose">‚úï</button>
    <h2>Storage üß≥ ‚Äî Personal Stash</h2>
    <div class="row" style="gap:8px; flex-wrap:wrap; margin-bottom:8px">
      <span class="pill">Stored <span id="storageCount">0</span></span>
    </div>
    <div style="display:grid; grid-template-columns: 1fr 1fr; gap:10px">
      <div>
        <h3 style="margin:4px 0 6px; font-size:14px">Inventory</h3>
        <div class="list" id="storInvList"></div>
      </div>
      <div>
        <h3 style="margin:4px 0 6px; font-size:14px">Storage</h3>
        <div class="list" id="storBoxList"></div>
      </div>
    </div>
  </div>
  <div class="window" id="charWin">
    <button class="close" id="charClose">‚úï</button>
    <h2>Character <span class="pill">Alt+C</span></h2>
    <div class="grid">
      <div class="paper">
        <h3 style="margin:2px 0 8px; font-size:14px">Equipment</h3>
        <div class="slots">
          <div class="slotrow"><span class="icon" id="charIconWeapon"></span><div><b>Weapon</b><div id="charWeapon">‚Äî</div></div></div>
          <div class="slotrow"><span class="icon" id="charIconHelmet"></span><div><b>Helmet</b><div id="charHelmet">‚Äî</div></div></div>
          <div class="slotrow"><span class="icon" id="charIconArmor"></span><div><b>Armor</b><div id="charArmor">‚Äî</div></div></div>
          <div class="slotrow"><span class="icon" id="charIconBoots"></span><div><b>Boots</b><div id="charBoots">‚Äî</div></div></div>
          <div class="slotrow"><span class="icon" id="charIconAcc"></span><div><b>Accessory</b><div id="charAcc">‚Äî</div></div></div>
          <div class="slotrow"><span class="icon" id="charIconWings"></span><div><b>Wings</b><div id="charWings">‚Äî</div></div></div>
          <div class="slotrow"><span class="icon" id="charIconShield"></span><div><b>Shield</b><div id="charShield">‚Äî</div></div></div>
        </div>
      </div>
      <div class="paper">
        <h3 style="margin:2px 0 8px; font-size:14px">Stats</h3>
        <div class="stats" id="charStats"></div>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>
</div>

<script>
(()=>{
  const el = id=>document.getElementById(id);
  const canvas = el('game');
  const ctx = canvas.getContext('2d');
  const minimapCanvas = el('minimap');
  const mapCtx = minimapCanvas.getContext && el('minimap').getContext? el('minimap').getContext('2d'):null;
  const minimapLabel = el('minimapLabel');
  const hpEl = el('hp'), mpEl = el('mp'), xpEl = el('xp');
  const lvEl = el('lv'), goldEl = el('gold'), nextxpEl = el('nextxp');
  const MAX_LEVEL = 50;
  const jobEl = el('job');
  const pnameEl = el('pname');
  const buffbarEl = el('buffbar');
  const eqWeapon = el('eqWeapon'), eqHelmet=el('eqHelmet'), eqArmor=el('eqArmor'), eqBoots=el('eqBoots'), eqAcc=el('eqAcc');
  const eqWings = el('eqWings');
  const invWin = el('invWin'), shopWin=el('shopWin'), jobWin=el('jobWin');
  const invList = el('invList'), shopList=el('shopList'), jobList=el('jobList');
  const invClose = el('invClose'), shopClose=el('shopClose'), jobClose=el('jobClose');
  const statsWin = el('statsWin'); const statsList = el('statsList'); const statsClose = el('statsClose');
  const charWin = el('charWin'); const charClose = el('charClose');
  const charWeapon = el('charWeapon'), charHelmet=el('charHelmet'), charArmor = el('charArmor'), charBoots=el('charBoots'), charAcc=el('charAcc'), charWings=el('charWings');
  const charStats = el('charStats');
  const storageWin = el('storageWin'); const storInvList = el('storInvList'); const storBoxList = el('storBoxList'); const storageClose = el('storageClose'); const storageCount = el('storageCount');
  let jobGuideWin = null;
  const invCount=el('invCount');
  const shopGold=el('shopGold');
  const hint=el('hint');
  const mountChip=el('mountChip');
  const questLine = el('quest-line'), questProg = el('quest-progress');
  const questReward = el('quest-reward');
  const overlay = el('overlay');
  const createOv = el('create');
  const ccName = el('cc-name'); const ccOutfit = el('cc-outfit'); const ccHair = el('cc-hair'); const ccSkin = el('cc-skin'); const ccWings = el('cc-wings'); const ccWeaponSel = el('cc-weapon');
  const ccPreview = el('cc-preview');
  const toast = el('toast');
  const stick = el('stick'), knob = el('knob'), atkBtn = el('atk');
  // Party & Friends UI containers
  let partyHud = null, friendsWin = null, partyWin = null;

  // Simple window dragging for all UI windows and panels
  function makeDraggable(winEl, handleSelector='h2'){
    if(!winEl) return;
    const handle = handleSelector? winEl.querySelector(handleSelector) : winEl;
    if(!handle) return;
    handle.style.cursor = 'move';
    let dragging=false, ox=0, oy=0, startLeft=0, startTop=0;
    function onDown(e){
      dragging=true; const rect=winEl.getBoundingClientRect();
      startLeft = rect.left; startTop = rect.top;
      ox = (e.touches? e.touches[0].clientX : e.clientX) - rect.left;
      oy = (e.touches? e.touches[0].clientY : e.clientY) - rect.top;
      // switch to left/top positioning
      winEl.style.right=''; winEl.style.bottom='';
      winEl.style.left = startLeft + 'px';
      winEl.style.top  = startTop + 'px';
      addEventListener('mousemove', onMove);
      addEventListener('mouseup', onUp);
      addEventListener('touchmove', onMove, {passive:false});
      addEventListener('touchend', onUp, {passive:false});
      e.preventDefault();
    }
    function onMove(e){ if(!dragging) return; const x=(e.touches? e.touches[0].clientX : e.clientX); const y=(e.touches? e.touches[0].clientY : e.clientY); winEl.style.left = Math.max(8, x-ox) + 'px'; winEl.style.top = Math.max(8, y-oy) + 'px'; if(e.cancelable) e.preventDefault(); }
    function onUp(){ dragging=false; removeEventListener('mousemove', onMove); removeEventListener('mouseup', onUp); removeEventListener('touchmove', onMove); removeEventListener('touchend', onUp); }
    handle.addEventListener('mousedown', onDown);
    handle.addEventListener('touchstart', onDown, {passive:false});
  }
  // Apply to built-in windows
  [invWin, shopWin, jobWin, statsWin, storageWin, charWin, document.querySelector('.quest')].forEach(w=> makeDraggable(w));

  // Friends & Party minimal data
  const SOCIAL_KEY='ap-social-v1';
  let friends = [];
  let party = { members: [] }; // each: {name, hp, hpMax}
  function loadSocial(){ try{ const s=JSON.parse(localStorage.getItem(SOCIAL_KEY)||'{}'); friends = Array.isArray(s.friends)? s.friends:[]; party = s.party||{members:[]}; }catch(e){ friends=[]; party={members:[]}; } }
  function saveSocial(){ try{ localStorage.setItem(SOCIAL_KEY, JSON.stringify({friends, party})); }catch(e){} }
  loadSocial();

  function openFriends(){
    if(!friendsWin){ friendsWin=document.createElement('div'); friendsWin.className='window'; friendsWin.style.display='none'; friendsWin.innerHTML=`<button class="close">‚úï</button><h2>Friends</h2><div class="list" id="friendsList"></div><div class="row" style="margin-top:8px; gap:6px"><input id="friendName" placeholder="Add player name" style="all:unset;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.14);padding:8px 10px;border-radius:10px"/><button id="friendAdd">Add</button></div>`; document.getElementById('game-wrap').appendChild(friendsWin); friendsWin.querySelector('.close').onclick=()=>friendsWin.style.display='none'; makeDraggable(friendsWin); }
    const list=friendsWin.querySelector('#friendsList'); list.innerHTML='';
    friends.forEach((n,i)=>{ const div=document.createElement('div'); div.className='item'; div.innerHTML=`<b>${n}</b>`; const actions=document.createElement('div'); const rm=document.createElement('button'); rm.textContent='Remove'; rm.onclick=()=>{ friends.splice(i,1); saveSocial(); openFriends(); }; actions.appendChild(rm); list.appendChild(div); list.appendChild(actions); });
    const addBtn=friendsWin.querySelector('#friendAdd'); const inp=friendsWin.querySelector('#friendName'); addBtn.onclick=()=>{ const v=(inp.value||'').trim(); if(v){ friends.push(v); inp.value=''; saveSocial(); openFriends(); }};
    friendsWin.style.display='block';
  }

  function openParty(){
    if(!partyWin){ partyWin=document.createElement('div'); partyWin.className='window'; partyWin.style.display='none'; partyWin.innerHTML=`<button class="close">‚úï</button><h2>Party</h2><div class="list" id="partyList"></div><div class="row" style="margin-top:8px; gap:6px"><input id="partyName" placeholder="Invite player name" style="all:unset;background:rgba(255,255,255,.06);border:1px solid rgba(255,255,255,.14);padding:8px 10px;border-radius:10px"/><button id="partyAdd">Invite</button><button id="partyLeave">Leave</button></div>`; document.getElementById('game-wrap').appendChild(partyWin); partyWin.querySelector('.close').onclick=()=>partyWin.style.display='none'; makeDraggable(partyWin); }
    const list=partyWin.querySelector('#partyList'); list.innerHTML='';
    const self = {name: player.name||'You', hp: player.hp|0, hpMax: player.hpMax|0};
    const merged = [self, ...party.members.filter(m=>m.name!==self.name)];
    merged.forEach((m,i)=>{ const div=document.createElement('div'); div.className='item'; const pct = Math.max(0, Math.min(1, (m.hp||0)/(m.hpMax||1))); div.innerHTML=`<b>${m.name}</b> <span class="pill">${(pct*100|0)}%</span>`; const actions=document.createElement('div'); if(i>0){ const rm=document.createElement('button'); rm.textContent='Kick'; rm.onclick=()=>{ party.members.splice(i-1,1); saveSocial(); openParty(); }; actions.appendChild(rm); } list.appendChild(div); list.appendChild(actions); });
    const addBtn=partyWin.querySelector('#partyAdd'); const inp=partyWin.querySelector('#partyName'); const leaveBtn=partyWin.querySelector('#partyLeave');
    addBtn.onclick=()=>{ const v=(inp.value||'').trim(); if(v){ party.members.push({name:v, hp:100, hpMax:100}); inp.value=''; saveSocial(); openParty(); }};
    leaveBtn.onclick=()=>{ party.members.length=0; saveSocial(); openParty(); };
    partyWin.style.display='block';
  }

  function ensurePartyHud(){
    if(partyHud) return partyHud;
    partyHud=document.createElement('div'); partyHud.style.position='absolute'; partyHud.style.right='12px'; partyHud.style.top='240px'; partyHud.style.background='var(--ui-bg)'; partyHud.style.padding='8px 10px'; partyHud.style.borderRadius='12px'; partyHud.style.border='1px solid rgba(255,255,255,.12)'; partyHud.style.font='12px system-ui'; partyHud.style.maxWidth='200px'; partyHud.style.pointerEvents='auto';
    partyHud.innerHTML = `<div style="display:flex;gap:6px;align-items:center;justify-content:space-between"><b>Party</b><span><button id="p-open" style="font-size:12px">Manage</button></span></div><div id="p-list" style="margin-top:6px;display:grid;gap:6px"></div>`;
    document.getElementById('game-wrap').appendChild(partyHud);
    makeDraggable(partyHud, null);
    partyHud.querySelector('#p-open').onclick = openParty;
    return partyHud;
  }

  function renderPartyHud(){ ensurePartyHud(); const list=partyHud.querySelector('#p-list'); list.innerHTML=''; const self = {name: player.name||'You', hp: player.hp|0, hpMax: player.hpMax|0}; const merged=[self, ...party.members.filter(m=>m.name!==self.name)]; merged.forEach(m=>{ const row=document.createElement('div'); row.style.display='grid'; row.style.gridTemplateColumns='auto 1fr'; row.style.gap='8px'; const bar=`<div style="position:relative; height:6px; background:rgba(255,255,255,.08); border-radius:6px"><i style="position:absolute;left:0;top:0;bottom:0; width:${Math.max(0,Math.min(1,(m.hp||0)/(m.hpMax||1)))*100}% ; background:var(--hp); border-radius:6px"></i></div>`; row.innerHTML = `<span>üë§ ${m.name}</span>${bar}`; list.appendChild(row); }); }

  const sicons=[el('sicon0'),el('sicon1'),el('sicon2'),el('sicon3')];
  const scds=[el('scd0'),el('scd1'),el('scd2'),el('scd3')];

  const DPR = Math.min(2, window.devicePixelRatio || 1);
  const W = ()=>Math.floor(innerWidth * DPR);
  const H = ()=>Math.floor(innerHeight * DPR);
  let vw=W(), vh=H();
  canvas.width = vw; canvas.height = vh;
  if(minimapCanvas){ minimapCanvas.width=180; minimapCanvas.height=120; }
  addEventListener('resize', ()=>{ vw=W(); vh=H(); canvas.width=vw; canvas.height=vh; if(Renderer && Renderer.gl){ try{ Renderer.gl.viewport(0,0,vw,vh);}catch(e){} } });

  // ==== SECTION: FEATURE FLAGS / GRAPHICS ====
  const GRAPHICS_DEFAULTS = {
    renderer: "webgl",          // "webgl" | "canvas"
    lighting: "basic",          // "off" | "basic" | "normalMapped"
    shadows: "blob",            // "off" | "blob" | "shadowmap"
    post: { bloom:false, vignette:true, aberration:false },
    mobilePreset: "med",
    caps: { butterflies: 18, flaenae: 8 }
  };
  const GRAPHICS = Object.assign({}, GRAPHICS_DEFAULTS, JSON.parse(localStorage.getItem('ap-graphics')||'{}'));
  function saveGraphics(){ try{ localStorage.setItem('ap-graphics', JSON.stringify(GRAPHICS)); }catch(e){} }

  // Simple FPS monitor and adaptive hooks (no heavy changes yet)
  const Perf = { smoothed:60, lowTimer:0 };
  function updatePerf(dt){ const fps = 1/Math.max(0.001,dt); Perf.smoothed = Perf.smoothed*0.9 + fps*0.1; if(Perf.smoothed<45){ Perf.lowTimer+=dt; } else { Perf.lowTimer=Math.max(0, Perf.lowTimer-dt*2); } if(Perf.lowTimer>3){ // progressive fallback
      if(GRAPHICS.post && GRAPHICS.post.bloom){ GRAPHICS.post.bloom=false; saveGraphics(); notify('Perf: disabling bloom'); Perf.lowTimer=0; return; }
      if(GRAPHICS.shadows==='shadowmap'){ GRAPHICS.shadows='blob'; saveGraphics(); notify('Perf: fallback to blob shadows'); Perf.lowTimer=0; return; }
      if(GRAPHICS.lighting==='normalMapped'){ GRAPHICS.lighting='basic'; saveGraphics(); notify('Perf: reducing lighting'); Perf.lowTimer=0; return; }
    } }

  // ==== RENDERER ADAPTER ====
  const Renderer = (function(){
    let gl=null; let backend='canvas'; let warned=false;
    function init(canvasEl){
      if(GRAPHICS.renderer==='webgl'){
        try{
          gl = canvasEl.getContext('webgl2', {antialias:false, premultipliedAlpha:true});
        }catch(e){ gl=null; }
        if(!gl){ backend='canvas'; if(!warned){ notify('WebGL not available ‚Äî using Canvas'); warned=true; } GRAPHICS.renderer='canvas'; }
        else { backend='webgl'; console.log('[Renderer] WebGL2 ready (stubbed draw path uses Canvas until Patch 3)'); }
      } else backend='canvas';
      return backend;
    }
    function beginFrame(){ ctx.clearRect(0,0,vw,vh); }
    const draw = {
      drawTiles(){ drawTiles(); },
      drawDecor(){ drawDecor(); },
      drawNPCs(){ drawNPCs(); },
      drawMobs(){ drawMobsSorted(); },
      drawProjs(){ drawProjectilesStage(); },
      drawPlayer(){ drawPlayer(); },
      drawFX(){ drawFXStage(); },
      drawOverlay(){ drawTransitionOverlay(); }
    };
    function endFrame(){ /* placeholder for postfx */ }
    return { init, beginFrame, draw, endFrame, get backend(){return backend;}, get gl(){return gl;} };
  })();

  // Initialize renderer (after canvas sized)
  Renderer.init(canvas);

  // ==== SECTION: TTS OPTION ====
  const TTS_KEY='ap-tts';
  let TTS_ENABLED = (()=>{ try{ return localStorage.getItem(TTS_KEY)==='1'; }catch(e){ return false; } })();
  function saveTTS(){ try{ localStorage.setItem(TTS_KEY, TTS_ENABLED?'1':'0'); }catch(e){} }
  function ttsSay(text){
    if(!TTS_ENABLED) return;
    const synth = window.speechSynthesis; if(!synth) return;
    try{ const u = new SpeechSynthesisUtterance(text); u.rate=1.0; u.pitch=1.0; u.volume=1.0; synth.cancel(); synth.speak(u); }catch(e){}
  }

  const rand = (a,b)=>a+Math.random()*(b-a);
  const clamp=(v,a,b)=>Math.max(a, Math.min(b,v));
  const dist=(ax,ay,bx,by)=>Math.hypot(ax-bx, ay-by);
  const now=()=>performance.now()/1000;

  // World
  const TILE=56; 
  const MAP_W=90, MAP_H=70; // ~ 5040x3920px
  const startPos = {x: TILE*4, y: TILE*6};
  let camera = {x:0,y:0};

  // Simple seeded PRNG for consistent decor
  let seed=1337; const r=()=> (seed = (seed*16807)%2147483647)/2147483647;

  const tiles = new Array(MAP_W*MAP_H).fill(0); // 0 grass, 1 dirt, 2 water
  // Town guard zones: populated per-map; enemies may not enter
  const townZones = [];
  // Plains-specific town center reference for spawn buffers
  let plainsTownCenter = null;
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      let idx=y*MAP_W+x;
      let g = (Math.sin(x*0.33)+Math.cos(y*0.27))*0.5 + r()*0.6; // pseudo noise
      tiles[idx] = g>0.55?1:0; // path or grass
    }
  }
  // Place a pond
  for(let y=20;y<28;y++) for(let x=20;x<28;x++){ if((x-24)**2+(y-24)**2<16) tiles[y*MAP_W+x]=2; }

  const decor=[]; // trees/rocks/flowers
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      if(tiles[y*MAP_W+x]===0 && r()>0.965) decor.push({t: r()>0.6? 'tree':'rock', x:x*TILE+rand(8,TILE-8), y:y*TILE+rand(8,TILE-8)});
      if(tiles[y*MAP_W+x]===0 && r()>0.985) decor.push({t:'flower', x:x*TILE+rand(10,TILE-10), y:y*TILE+rand(10,TILE-10)});
    }
  }

  // Entities
  const ents = [];
  const projs=[]; // projectiles
  const fx=[]; // transient visuals
  const drops=[]; // ground loot {x,y,t:time, gold?, item?}
  const turrets=[]; // dealer skill
  const portals=[]; // map portals
  let storageBox=[]; // persistent storage

  // Items & Shop (ensure specified weapon stats)
  const ITEM_DB={
    potion_hp:{name:'Small Potion', type:'consumable', hp:50, price:10},
    potion_mp:{name:'Mana Drink', type:'consumable', mp:40, price:10},
    wood_sword:{name:'Training Sword (1H)', type:'gear', slot:'weapon', wep:'sword1h', atk:6, price:60, ilvl:1, reqLv:1},
    wood_2h_sword:{name:'Training Greatsword (2H)', type:'gear', slot:'weapon', wep:'sword2h', atk:10, aspd:1.12, price:90, ilvl:2, reqLv:2},
    wood_shield:{name:'Training Shield', type:'gear', slot:'shield', def:6, price:50, socket:null, ilvl:2, reqLv:2},
    wood_gun:{name:'Training Pistol', type:'gear', slot:'weapon', wep:'gun', atk:7, aspd:0.85, price:85, ilvl:3, reqLv:3},
    wood_bow:{name:'Training Bow', type:'gear', slot:'weapon', wep:'bow', atk:5, price:70, ilvl:1, reqLv:1},
    wood_katar:{name:'Training Katar', type:'gear', slot:'weapon', wep:'katar', atk:5, speed:20, aspd:0.8, price:70, ilvl:2, reqLv:2},
    wood_staff:{name:'Training Staff', type:'gear', slot:'weapon', wep:'staff', atk:7, mpMax:10, price:80, ilvl:2, reqLv:2},
    wood_wand:{name:'Training Wand', type:'gear', slot:'weapon', wep:'wand', atk:5, price:80, ilvl:2, reqLv:2},
    leather_armor:{name:'Leather Armor', type:'gear', slot:'armor', hpMax:20, price:60, ilvl:3, reqLv:3},
    runner_shoes:{name:'Runner Shoes', type:'gear', slot:'boots', speed:40, price:80, ilvl:3, reqLv:3},
    feather_charm:{name:'Feather Charm', type:'gear', slot:'accessory', speed:30, price:90, ilvl:4, reqLv:4},
    royal_core:{name:'Royal Core', type:'gear', slot:'accessory', atk:8, hpMax:30, price:0, ilvl:5, reqLv:5},
    power_candy:{name:'Power Candy', type:'consumable', atk:4, dur:45, price:25},
    junon_scroll:{name:'Return Scroll: Junon Polis', type:'consumable', teleport:'junon', spawnTag:'gate', price:0},
    cart_pass:{name:'Cart License', type:'vehicle', vehicle:'cart', price:0},
    // Mid-tier gear for Zant/Junon tiers
    bronze_sword:{name:'Bronze Sword', type:'gear', slot:'weapon', wep:'sword', atk:14, price:160, ilvl:6, reqLv:6},
    iron_sword:{name:'Iron Sword', type:'gear', slot:'weapon', wep:'sword', atk:22, price:300, ilvl:12, reqLv:12},
    oak_bow:{name:'Oak Bow', type:'gear', slot:'weapon', wep:'bow', atk:12, price:180, ilvl:7, reqLv:7},
    composite_bow:{name:'Composite Bow', type:'gear', slot:'weapon', wep:'bow', atk:20, price:280, ilvl:12, reqLv:12},
    fine_katar:{name:'Fine Katar', type:'gear', slot:'weapon', wep:'katar', atk:14, aspd:0.9, price:220, ilvl:8, reqLv:8},
    battle_staff:{name:'Battle Staff', type:'gear', slot:'weapon', wep:'staff', atk:20, mpMax:20, price:260, ilvl:12, reqLv:12},
    mystic_wand:{name:'Mystic Wand', type:'gear', slot:'weapon', wep:'wand', atk:18, price:260, ilvl:11, reqLv:11},
    steel_armor:{name:'Steel Armor', type:'gear', slot:'armor', hpMax:80, price:240, ilvl:9, reqLv:9},
    swift_boots:{name:'Swift Boots', type:'gear', slot:'boots', speed:80, price:220, ilvl:8, reqLv:8},
    rocket_launcher:{name:'Rocket Launcher', type:'gear', slot:'weapon', wep:'launcher', atk:28, aspd:1.2, price:420, ilvl:13, reqLv:13},
    // New slots
    cap_basic:{name:'Basic Cap', type:'gear', slot:'helmet', def:4, price:90, ilvl:2, reqLv:2},
    helmet_iron:{name:'Iron Helmet', type:'gear', slot:'helmet', def:12, hpMax:20, price:180, ilvl:9, reqLv:9},
    helmet_knight:{name:'Knight Helm', type:'gear', slot:'helmet', def:22, hpMax:40, price:320, ilvl:14, reqLv:14},
    cloak_travel:{name:'Traveler Cloak', type:'gear', slot:'wings', speed:40, style:'none', price:140, ilvl:6, reqLv:6},
    cloak_royal:{name:'Royal Cape', type:'gear', slot:'wings', speed:80, hpMax:20, style:'none', price:260, ilvl:12, reqLv:12},
    ring_bronze:{name:'Bronze Ring', type:'gear', slot:'accessory', atk:2, price:70, ilvl:2, reqLv:2},
    ring_silver:{name:'Silver Ring', type:'gear', slot:'accessory', atk:4, price:140, ilvl:7, reqLv:7},
    ring_gold:{name:'Golden Ring', type:'gear', slot:'accessory', atk:6, price:240, ilvl:12, reqLv:12},
    // Wings gear (rebalance)
    butterfly_wings:{name:'Butterfly Wings', type:'gear', slot:'wings', speed:80, style:'butterfly', price:0, ilvl:1, reqLv:1},
    dragon_worm_wings:{name:'Dragon Worm Wings', type:'gear', slot:'wings', speed:160, hpMax:60, style:'angel', price:260, ilvl:15, reqLv:15},
    angel_wings:{name:'Angel Wings', type:'gear', slot:'wings', speed:120, hpMax:40, style:'angel', price:220, ilvl:12, reqLv:12},
    bat_wings:{name:'Bat Wings', type:'gear', slot:'wings', speed:100, style:'bat', price:180, ilvl:8, reqLv:8},
    feather_wings:{name:'Feathered Wings', type:'gear', slot:'wings', speed:110, style:'feather', price:200, ilvl:11, reqLv:11},
    mechanical_wings:{name:'Mechanical Wings', type:'gear', slot:'wings', speed:100, hpMax:20, style:'mechanical', price:240, ilvl:12, reqLv:12},
    fairy_wings:{name:'Fairy Wings', type:'gear', slot:'wings', speed:90, style:'fairy', price:150, ilvl:4, reqLv:4},
    // Extra travel scrolls
    zant_scroll:{name:'Return Scroll: Zant', type:'consumable', teleport:'zant', spawnTag:'plaza', price:0},
    elver_scroll:{name:'Return Scroll: El Verloon Desert', type:'consumable', teleport:'elverloon', spawnTag:'oasis', price:0},
    eldeon_scroll:{name:'Return Scroll: Eldeon Glade', type:'consumable', teleport:'eldeon', spawnTag:'gate', price:0}
  };
  // Gem items (slot: gem) ‚Äî set all shop prices to 500 gold
  Object.assign(ITEM_DB, {
    t7:{name:'T7 Gem', type:'gear', slot:'gem', bonus:{int:5}, price:500, ilvl:10},
    g7:{name:'G7 Gem', type:'gear', slot:'gem', bonus:{dex:5}, price:500, ilvl:10},
    r7:{name:'R7 Gem', type:'gear', slot:'gem', bonus:{str:5}, price:500, ilvl:10},
    s7:{name:'S7 Gem', type:'gear', slot:'gem', bonus:{con:5}, price:500, ilvl:10},
    emerald7:{name:'Emerald 7', type:'gear', slot:'gem', bonus:{sen:5}, price:500, ilvl:10}
  });
  const SHOP_STOCK_BASE=['potion_hp','potion_mp','wood_sword','wood_2h_sword','wood_shield','wood_bow','wood_katar','wood_staff','wood_wand','wood_gun','leather_armor','runner_shoes','feather_charm','power_candy','rocket_launcher','butterfly_wings','fairy_wings','cap_basic','ring_bronze','t7','g7','r7','s7','emerald7'];
  const SHOP_STOCK_MID=['potion_hp','potion_mp','bronze_sword','oak_bow','fine_katar','battle_staff','mystic_wand','steel_armor','swift_boots','power_candy','angel_wings','dragon_worm_wings','bat_wings','helmet_iron','ring_silver','cloak_travel','wood_gun'];
  const SHOP_STOCK_HIGH=['potion_hp','potion_mp','iron_sword','composite_bow','fine_katar','battle_staff','mystic_wand','steel_armor','swift_boots','power_candy','angel_wings','dragon_worm_wings','mechanical_wings','feather_wings','helmet_knight','ring_gold','cloak_royal','wood_2h_sword'];

  // Map ‚Üí allowed item-level range for shop/drops
  const MAP_ITEM_LEVELS = { plains:[1,5], zant:[5,10], elverloon:[5,15], junon:[15,20], canyon:[20,30], luna:[30,40], eldeon:[40,50] };
  function itemAllowedInMap(it){
    if(!it) return false;
    if(it.type !== 'gear') return true; // consumables etc always allowed
    const [lo,hi] = MAP_ITEM_LEVELS[mapName] || [1, MAX_LEVEL];
    const lvl = (it.ilvl||it.reqLv||1)|0;
    return lvl>=lo && lvl<=hi;
  }

  function getShopStock(){
    const base = (mapName==='plains')? SHOP_STOCK_BASE : (mapName==='junon'? (player.level>=10? SHOP_STOCK_HIGH : SHOP_STOCK_MID) : SHOP_STOCK_MID);
    return base.filter(id=> itemAllowedInMap(ITEM_DB[id]));
  }
  // Item icon inline SVG (minimal, readable)
  function getItemIconSVG(id){
    const it = ITEM_DB[id];
    if(!it) return '';
    const color = (c)=>c;
    const svg=(path)=>`<svg viewBox="0 0 24 24" aria-hidden="true">${path}</svg>`;
    if(it.slot==='weapon' || it.wep){
      if(it.wep==='sword1h') return svg(`<path fill="${color('#d9d9d9')}" d="M3 20l3 1 8-8-2-2-8 8z"/><rect fill="#999" x="12" y="5" width="8" height="3" rx="1"/>`);
      if(it.wep==='sword2h') return svg(`<rect fill="#bbb" x="8" y="4" width="10" height="4" rx="1"/><rect fill="#ddd" x="6" y="8" width="14" height="4" rx="1"/><rect fill="#999" x="10" y="12" width="6" height="6" rx="1"/>`);
      if(it.wep==='bow') return svg(`<path fill="none" stroke="#d9e8a8" stroke-width="2" d="M6 4c8 6 8 10 0 16"/><path fill="#cfa" d="M5 11h10v2H5z"/>`);
      if(it.wep==='katar') return svg(`<rect fill="#ccc" x="5" y="6" width="12" height="3"/><rect fill="#ccc" x="5" y="14" width="12" height="3"/>`);
      if(it.wep==='staff') return svg(`<rect fill="#b98f5a" x="10" y="3" width="4" height="18" rx="1"/><circle fill="#8ee" cx="12" cy="5" r="3"/>`);
      if(it.wep==='wand') return svg(`<rect fill="#b98f5a" x="11" y="7" width="3" height="12" rx="1"/><circle fill="#f6f" cx="12.5" cy="8" r="2"/>`);
      if(it.wep==='launcher') return svg(`<rect fill="#888" x="6" y="9" width="12" height="6" rx="2"/><path fill="#f5a76e" d="M3 11h6v2H3z"/>`);
      if(it.wep==='gun') return svg(`<rect fill="#555" x="5" y="10" width="14" height="4" rx="1"/><rect fill="#333" x="9" y="14" width="4" height="5"/>`);
    }
    if(it.slot==='shield') return svg(`<circle fill="#89a" cx="12" cy="12" r="8"/><circle fill="#bcd" cx="12" cy="12" r="4"/>`);
    if(it.slot==='helmet') return svg(`<path fill="#9ab" d="M4 14a8 8 0 0 1 16 0v2H4z"/>`);
    if(it.slot==='armor') return svg(`<rect fill="#7aa" x="5" y="5" width="14" height="14" rx="3"/>`);
    if(it.slot==='boots') return svg(`<path fill="#aa7" d="M4 15h10v3H7a3 3 0 0 1-3-3z"/>`);
    if(it.slot==='accessory') return svg(`<circle fill="#ffd24a" cx="12" cy="12" r="6"/>`);
    if(it.slot==='wings') return svg(`<path fill="#9cf" d="M4 12c4-6 8-6 10-2-5 0-6 2-10 2z"/><path fill="#f9c" d="M4 12c4 2 5 4 10 4-2 4-6 2-10-4z"/>`);
    if(it.slot==='gem' && it.bonus){ const key = Object.keys(it.bonus)[0]; const col = key==='str'? '#ff6b6b' : key==='dex'? '#71e6a2' : key==='int'? '#6ab3ff' : key==='con'? '#cfcfcf' : '#4ef3a2'; return svg(`<path fill="${col}" d="M12 3l6 6-6 12-6-12 6-6z"/>`); }
    if(it.type==='consumable' && /potion|drink/i.test(it.name)) return svg(`<rect fill="#6cf" x="7" y="5" width="10" height="14" rx="2"/><rect fill="#9cf" x="9" y="7" width="6" height="8"/>`);
    if(it.type==='consumable' && /scroll/i.test(it.name)) return svg(`<path fill="#ddb" d="M6 6h12v10H6z"/><circle fill="#ccb" cx="6" cy="8" r="2"/><circle fill="#ccb" cx="18" cy="14" r="2"/>`);
    if(id==='cart_pass') return svg(`<rect fill="#7ac" x="5" y="7" width="14" height="10" rx="2"/><rect fill="#9de" x="7" y="10" width="10" height="2"/>`);
    return svg(`<circle fill="#cfe" cx="12" cy="12" r="6"/>`);
  }

  // Player, Inventory & Equipment
  function makePlayer(){
    return {
      kind:'player', x:startPos.x, y:startPos.y, r:18, baseSpeed:150, speed:150, dir:0,
      hp:100, hpMax:100, mp:60, mpMax:60, level:1, xp:0, gold:0,
      atk:12, baseAtk:12, atkCd:0.44, atkTimer:0, projSpeed:430, alive:true,
      inv:[], invCap:26, eq:{weapon:null, helmet:null, armor:null, boots:null, accessory:null, wings:null, shield:null},
      buffs:[], hasCartPass:false, mounted:false,
      job:'Visitor', skills:[null,null,null,null], skillCd:[0,0,0,0], flags:{cartUnlocked:false},
      statPoints: 0,
      name: '',
      appearance: { outfit:'#2a6aa8', hair:'#3a2a1a', skin:'#f2d6c2', wingsStyle:'butterfly' },
      defBase: 0, mdefBase: 0, accBase: 0.78, critBonus: 0,
      swingT: 0
    };
  }
  let player = makePlayer();

  function recalcStats(){
    let atk=player.baseAtk, hpMax=100, speed=player.baseSpeed, atkCd=0.48, mpMax=player.mpMax;
    for(const k of ['weapon','helmet','armor','boots','accessory','wings','shield']){
      const itemId = player.eq[k]; if(!itemId) continue; const it=ITEM_DB[itemId];
      let mult = 1 + ((it.refine|0) * 0.06); // +6% stats per refine level
      if(it.atk) atk += Math.round(it.atk * mult);
      if(it.hpMax) hpMax += Math.round(it.hpMax * mult);
      if(it.speed) speed += Math.round(it.speed * mult);
      if(it.def) player.defBase = (player.defBase|0) + Math.round(it.def * mult);
      if(it.aspd) atkCd *= Math.max(0.9, 1 - (1-it.aspd)*mult);
      if(it.mpMax) mpMax = (mpMax||player.mpMax) + Math.round(it.mpMax * mult);
      // gem socket bonus (weapon/armor/wings/shield)
      if(it.socket && ITEM_DB[it.socket] && ITEM_DB[it.socket].bonus){ const g=ITEM_DB[it.socket].bonus; if(g.str) atk+=g.str; if(g.dex) speed+=g.dex*3; if(g.int) mpMax = (mpMax||player.mpMax) + g.int*2; if(g.con) player.defBase += g.con; }
    }
    // Set bonuses (2pc/3pc) example for iron/steel tier
    const equipped = Object.values(player.eq).filter(Boolean);
    const countOf = (arr)=> arr.filter(id=>equipped.includes(id)).length;
    const junonSet = ['iron_sword','steel_armor','helmet_knight'];
    const nJunon = countOf(junonSet);
    if(nJunon>=2){ atk += 6; }
    if(nJunon>=3){ player.defBase = (player.defBase|0) + 10; }
    // Gem items exist but are not equippable by players
    // Derived defenses and rates
    let def = player.defBase||0, mdef = player.mdefBase||0, acc = player.accBase||0.78, critAdd = 0;
    for(const b of player.buffs){ if(b.atk) atk+=b.atk; if(b.speed) speed+=b.speed; if(b.hpMax) hpMax+=b.hpMax; if(b.aspd) atkCd*=b.aspd; if(b.def) def+=b.def; if(b.mdef) mdef+=b.mdef; if(b.acc) acc+=b.acc; if(b.crit) critAdd+=b.crit; }
    // Stat influences
    const s = player.stats || (player.stats={str:0,dex:0,int:0,sen:0,con:0});
    atk = Math.round(atk + (s.str||0)*1.0);
    speed += (s.dex||0) * 3.5;
    // DEX increases attack speed meaning lower cooldown
    const dex = (s.dex||0);
    atkCd = Math.max(0.24, atkCd * (1 - Math.min(0.28, dex*0.018)));
    acc += (s.con||0) * 0.015; // +1.5% per CON
    critAdd += (s.sen||0) * 0.01 * 0; // SEN handled in calcDamage baseline; additive bonus via buffs
    player.critBonus = critAdd;
    player.def = Math.max(0, def);
    player.mdef = Math.max(0, mdef);
    if(player.mounted){ speed += 120; }
    player.atk = atk; player.hpMax = hpMax; player.speed = speed; player.atkCd = clamp(atkCd, 0.24, 0.9); player.mpMax = mpMax||player.mpMax; player.acc = clamp(acc, 0.05, 0.98);
    if(player.hp>player.hpMax) player.hp=player.hpMax;
    if(player.mp>player.mpMax) player.mp=player.mpMax;
  }

  function addToInv(itemId, qty=1){
    const it=ITEM_DB[itemId]; if(!it) return false;
    // Prevent adding out-of-map gear via shop or rewards unless explicitly allowed
    if(!itemAllowedInMap(it) && it.type==='gear'){
      // As a safety, block adding gear that exceeds current map item level gate (drops are filtered earlier)
      // Quests that intentionally reward higher gear should use consumables or teleport the player first
      return false;
    }
    if(it.type==='consumable'){
      const slot = player.inv.find(x=>x.id===itemId && x.stack!=null);
      if(slot){ slot.stack+=qty; } else { player.inv.push({id:itemId, stack:qty}); }
    } else {
      for(let i=0;i<qty;i++){ if(player.inv.length<player.invCap) player.inv.push({id:itemId}); else { notify('Inventory full'); return false; } }
    }
    save(); return true;
  }

  function useItem(index){
    const entry=player.inv[index]; if(!entry) return; const it=ITEM_DB[entry.id];
    if(it.type==='consumable'){
      // Reset stats scroll
      if(entry.id==='reset_scroll'){
        const spent = (player.stats.str|0)+(player.stats.dex|0)+(player.stats.int|0)+(player.stats.sen|0)+(player.stats.con|0);
        player.statPoints = (player.statPoints|0) + spent; player.stats={str:0,dex:0,int:0,sen:0,con:0};
        if(entry.stack){ entry.stack--; if(entry.stack<=0) player.inv.splice(index,1); } else player.inv.splice(index,1);
        recalcStats(); save(); notify('Stats reset'); renderInventory(); return; }
      // Teleport scrolls (e.g., Return Scroll: Junon Polis)
      if(it.teleport){ if(entry.stack){ entry.stack--; if(entry.stack<=0) player.inv.splice(index,1); } else player.inv.splice(index,1); const dest = it.teleport; const tag = it.spawnTag || 'main'; notify('Teleporting...'); changeMap(dest, tag); saveMeta(); save(); return; }
      if(it.hp) player.hp = clamp(player.hp+it.hp, 0, player.hpMax);
      if(it.mp) player.mp = clamp(player.mp+it.mp, 0, player.mpMax);
      if(it.atk){ player.buffs.push({atk:it.atk, t:it.dur||30}); }
      if(entry.stack){ entry.stack--; if(entry.stack<=0) player.inv.splice(index,1); } else player.inv.splice(index,1);
      recalcStats(); save(); notify('Used '+it.name);
    } else if(it.type==='vehicle'){
      player.hasCartPass=true; player.flags.cartUnlocked=true; player.inv.splice(index,1); notify('Cart License acquired (press C to summon)'); save();
    }
    renderInventory();
  }

  // Enforce level requirement on equip
  function canEquip(it){
    if(!it || it.type!=='gear') return false;
    const req = (it.reqLv||1)|0;
    return (player.level|0) >= req;
  }

  function equipItem(index){
    const entry=player.inv[index]; if(!entry) return; const it=ITEM_DB[entry.id]; if(!it||it.type!=='gear') return;
    if(it.slot==='gem'){ openSocketWindow(index); return; }
    if(!canEquip(it)){ notify(`Requires Lv ${it.reqLv||1}`); return; }
    const slot=it.slot; const prev = player.eq[slot]; player.eq[slot]=entry.id; player.inv.splice(index,1); if(prev) player.inv.push({id:prev});
    notify('Equipped '+it.name); recalcStats(); save(); renderInventory();
  }

  function statsText(it){
    const prettyWep = it.wep==='sword1h'? 'SWORD (1H)' : it.wep==='sword2h'? 'SWORD (2H)' : (it.wep? it.wep.toUpperCase() : '');
    const lvPart = (it.type==='gear')? `LVL ${it.ilvl||it.reqLv||1}${it.reqLv?` ¬∑ REQ ${it.reqLv}`:''}` : '';
    const parts=[ lvPart, prettyWep, it.atk?`ATK +${it.atk}`:'', it.hpMax?`HP +${it.hpMax}`:'', it.speed?`SPD +${it.speed}`:'', it.aspd?`ASPD x${it.aspd}`:'', it.mpMax?`MP +${it.mpMax}`:'', it.hp?`Heal ${it.hp}`:'', it.mp?`MP +${it.mp}`:'', it.dur?`${it.dur}s`:'', it.def?`DEF +${it.def}`:'' ];
    if(it.slot==='gem' && it.bonus){ const k=Object.keys(it.bonus)[0]; parts.push(`${k.toUpperCase()} +${it.bonus[k]}`); }
    return parts.filter(Boolean).join(' ¬∑ ');
  }

  function renderInventory(){
    invCount.textContent = player.inv.length+"/"+player.invCap;
    eqWeapon.textContent = player.eq.weapon? ITEM_DB[player.eq.weapon].name: '‚Äî';
    if(eqHelmet) eqHelmet.textContent = player.eq.helmet? ITEM_DB[player.eq.helmet].name: '‚Äî';
    eqArmor.textContent  = player.eq.armor? ITEM_DB[player.eq.armor].name: '‚Äî';
    eqBoots.textContent  = player.eq.boots? ITEM_DB[player.eq.boots].name: '‚Äî';
    eqAcc.textContent    = player.eq.accessory? ITEM_DB[player.eq.accessory].name: '‚Äî';
    if(eqWings) eqWings.textContent = player.eq.wings? ITEM_DB[player.eq.wings].name : '‚Äî';
      invList.innerHTML='';
    player.inv.forEach((entry,i)=>{
      const it=ITEM_DB[entry.id];
      const icon = getItemIconSVG(entry.id);
      const div=document.createElement('div'); div.className='item'; div.innerHTML=`<div style=\"display:flex;align-items:center\"><span class=\"icon\">${icon}</span><div><b>${it.name}</b> <span class=\"pill\">${it.type}</span> ${entry.stack? `<span class=\"pill\">x${entry.stack}</span>`:''}<div style=\"font-size:12px; opacity:.85; margin-top:4px\">${statsText(it)}</div></div></div>`;
      const actions=document.createElement('div'); const btn=document.createElement('button');
      btn.textContent = it.type==='gear'? (it.slot==='gem'? 'Socket' : 'Equip') : (it.type==='consumable'? 'Use' : 'Learn');
      btn.onclick=()=>{ if(it.type==='gear'){ if(it.slot==='gem'){ openSocketWindow(i); } else equipItem(i); } else if(it.type==='consumable') useItem(i); else if(it.type==='vehicle') useItem(i); };
      actions.appendChild(btn); invList.appendChild(div); invList.appendChild(actions);
    });
  }

  function openInventory(){ invWin.style.display='block'; renderInventory(); }
  function closeInventory(){ invWin.style.display='none'; }
  function openShop(){ shopGold.textContent = player.gold|0; shopList.innerHTML=''; getShopStock().forEach(id=>{
      const it=ITEM_DB[id]; const div=document.createElement('div'); div.className='item';
      const icon = getItemIconSVG(id);
      div.innerHTML=`<div style=\"display:flex;align-items:center\"><span class=\"icon\">${icon}</span><div><b>${it.name}</b> <span class=\"pill\">${it.type}</span> <span class=\"pill\">${it.price}‚ú¶</span> ${(it.reqLv?`<span class=\"pill\">Req ${it.reqLv}</span>`:'')} ${(it.ilvl?`<span class=\"pill\">iLv ${it.ilvl}</span>`:'')}<div style=\"font-size:12px; opacity:.85; margin-top:4px\">${statsText(it)}</div>${(it.type==='gear' && !canEquip(it))? `<div style=\\"font-size:12px;color:#f88;margin-top:4px\\">Requires Lv ${it.reqLv||1}</div>`:''}</div></div>`;
      const actions=document.createElement('div'); const btn=document.createElement('button'); btn.textContent='Buy'; btn.onclick=()=>{ if(player.gold>=it.price){ player.gold-=it.price; addToInv(id,1); shopGold.textContent=player.gold|0; goldEl.textContent=player.gold|0; notify('Purchased '+it.name); } else notify('Not enough gold'); };
      actions.appendChild(btn); shopList.appendChild(div); shopList.appendChild(actions);
    });
    const lblMap = {plains:'Adventure Plains', zant:'Zant', junon:'Junon Polis', elverloon:'El Verloon Desert', luxem:'Luxem Forest', canyon:'Gorge Canyon', luna:'Luna', eldeon:'Eldeon Glade'};
    const lbl = lblMap[mapName] || 'Merchant';
    const range = MAP_ITEM_LEVELS[mapName] || [1, MAX_LEVEL];
    const shopMapLabel = document.getElementById('shopMapLabel'); if(shopMapLabel) shopMapLabel.textContent = `${lbl} Shop (Lv ${range[0]}‚Äì${range[1]})`;
    shopWin.style.display='block'; shopList.scrollTop=0; ttsSay('Hello fellow rosarian, i have some items that may help ease your journey'); }
  function closeShop(){ shopWin.style.display='none'; }
  invClose.onclick=closeInventory; shopClose.onclick=closeShop; jobClose.onclick=()=>jobWin.style.display='none'; statsClose.onclick=()=>statsWin.style.display='none'; storageClose.onclick=()=>storageWin.style.display='none';

  // Storage (simple stash)
  const STORAGE_KEY='ap-storage-v1';
  function saveStorage(){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(storageBox)); }catch(e){} }
  function loadStorage(){ try{ storageBox = JSON.parse(localStorage.getItem(STORAGE_KEY)||'[]'); if(!Array.isArray(storageBox)) storageBox=[]; }catch(e){ storageBox=[]; } }
  function renderStorage(){
    storageCount.textContent = (storageBox.length||0);
    // Inventory side: items you can store
    storInvList.innerHTML='';
    player.inv.forEach((entry,i)=>{
      const it=ITEM_DB[entry.id]; if(!it) return;
      const icon = getItemIconSVG(entry.id);
      const div=document.createElement('div'); div.className='item'; div.innerHTML=`<div style="display:flex;align-items:center"><span class="icon">${icon}</span><div><b>${it.name}</b> <span class="pill">${it.type}</span> ${entry.stack? `<span class="pill">x${entry.stack}</span>`:''}</div></div>`;
      const actions=document.createElement('div'); const btn=document.createElement('button'); btn.textContent='Store'; btn.onclick=()=>{
        // Split stacks when possible
        if(entry.stack && entry.stack>1){ entry.stack--; storageBox.push({id:entry.id, stack:1}); }
        else { storageBox.push(entry); player.inv.splice(i,1); }
        save(); saveStorage(); renderInventory(); renderStorage(); notify('Stored item'); };
      actions.appendChild(btn); storInvList.appendChild(div); storInvList.appendChild(actions);
    });
    // Storage side: items to withdraw
    storBoxList.innerHTML='';
    storageBox.forEach((entry,i)=>{
      const it=ITEM_DB[entry.id]; if(!it) return;
      const icon = getItemIconSVG(entry.id);
      const div=document.createElement('div'); div.className='item'; div.innerHTML=`<div style=\"display:flex;align-items:center\"><span class=\"icon\">${icon}</span><div><b>${it.name}</b> <span class=\"pill\">${it.type}</span> ${entry.stack? `<span class=\\"pill\\">x${entry.stack}</span>`:''}</div></div>`;
      const actions=document.createElement('div'); const btn=document.createElement('button'); btn.textContent='Withdraw'; btn.onclick=()=>{
        if(it.type==='consumable' && entry.stack && entry.stack>1){ entry.stack--; addToInv(entry.id,1); }
        else { addToInv(entry.id, entry.stack||1); storageBox.splice(i,1); }
        saveStorage(); renderInventory(); renderStorage(); notify('Withdrew item'); };
      actions.appendChild(btn); storBoxList.appendChild(div); storBoxList.appendChild(actions);
    });
  }
  function openStorage(){ storageWin.style.display='block'; renderStorage(); }

  // Simple per-map quest giver interaction prompt when near Trainer (acts as quest giver)
  function openMapBounties(){
    if(mapName==='zant'){ qIndex = quests.findIndex(q=>q.id===10); if(qIndex<0){ quests.push({id:10, title:'Zant Bounty: Choropy', line:'Defeat 12 Choropys around Luxem and Zant outskirts.', need:12, type:'choropy', prog:0, done:false, reward:{xp:260,gold:240}}); qIndex = quests.length-1; }
      notify('New bounty accepted: Choropy Hunt'); save(); }
    else if(mapName==='junon'){ qIndex = quests.findIndex(q=>q.id===11); if(qIndex<0){ quests.push({id:11, title:'Junon Bounty: Moldy', line:'Defeat 10 Moldy Spores near the city.', need:10, type:'moldy', prog:0, done:false, reward:{xp:340,gold:300}}); qIndex = quests.length-1; }
      notify('New bounty accepted: Moldy Spores'); save(); }
    else if(mapName==='elverloon'){ qIndex = quests.findIndex(q=>q.id===12); if(qIndex<0){ quests.push({id:12, title:'El Verloon Bounty: Golems', line:'Defeat 6 Rock Golems in the dunes.', need:6, type:'rockgolem', prog:0, done:false, reward:{xp:520,gold:420}}); qIndex = quests.length-1; }
      notify('New bounty accepted: Golems'); save(); }
    else if(mapName==='luxem'){ qIndex = quests.findIndex(q=>q.id===10); if(qIndex<0){ quests.push({id:10, title:'Zant Bounty: Choropy', line:'Defeat 12 Choropys around Luxem and Zant outskirts.', need:12, type:'choropy', prog:0, done:false, reward:{xp:260,gold:240}}); qIndex = quests.length-1; }
      notify('New bounty accepted: Choropy Hunt'); save(); }
    else if(mapName==='eldeon'){ qIndex = quests.findIndex(q=>q.id===41); if(qIndex<0){ quests.push({id:41, title:'Eldeon Hunt', line:'Defeat 10 Eldeon foes (Spirit Archers or Thornlings).', need:10, type:'eldeon_kill', prog:0, done:false, reward:{xp:800,gold:700}}); qIndex = quests.length-1; } notify('New bounty accepted: Eldeon Hunt'); save(); }
    updateQuestText();
  }

  // Character window rendering
  function iconForEq(id){ return id? getItemIconSVG(id) : ''; }
  function openCharacter(){
    if(!charWin) return;
    charWeapon.textContent = player.eq.weapon? ITEM_DB[player.eq.weapon].name : '‚Äî';
    if(charHelmet) charHelmet.textContent = player.eq.helmet? ITEM_DB[player.eq.helmet].name : '‚Äî';
    charArmor.textContent  = player.eq.armor? ITEM_DB[player.eq.armor].name : '‚Äî';
    charBoots.textContent  = player.eq.boots? ITEM_DB[player.eq.boots].name : '‚Äî';
    charAcc.textContent    = player.eq.accessory? ITEM_DB[player.eq.accessory].name : '‚Äî';
    charWings.textContent  = player.eq.wings? ITEM_DB[player.eq.wings].name : '‚Äî';
    const charShield = document.getElementById('charShield'); if(charShield) charShield.textContent = player.eq.shield? ITEM_DB[player.eq.shield].name + (ITEM_DB[player.eq.shield].socket? ` [${ITEM_DB[ITEM_DB[player.eq.shield].socket].name}]`:'') : '‚Äî';
    // icons
    const setIcon=(elId,id)=>{ const elx=document.getElementById(elId); if(elx) elx.innerHTML = iconForEq(id); };
    setIcon('charIconWeapon', player.eq.weapon);
    setIcon('charIconHelmet', player.eq.helmet);
    setIcon('charIconArmor', player.eq.armor);
    setIcon('charIconBoots', player.eq.boots);
    setIcon('charIconAcc', player.eq.accessory);
    setIcon('charIconWings', player.eq.wings);
    setIcon('charIconShield', player.eq.shield);
    // stats grid
    const s = player.stats || (player.stats={str:0,dex:0,int:0,sen:0,con:0});
    const lines = [
      ['Name', String(player.name||'Rosarian')],
      ['LV', String(player.level)],
      ['Attack Power', String(player.atk|0)],
      ['HP', `${player.hp|0}/${player.hpMax|0}`],
      ['MP', `${player.mp|0}/${player.mpMax|0}`],
      ['Attack Speed', (player.atkCd? (1/player.atkCd).toFixed(2)+' /s' : '‚Äî')],
      ['Movement Speed', String(Math.round(player.speed))],
      ['Magic Defense', String(player.mdef|0)],
      ['Accuracy', ((player.acc||0.78)*100|0)+'%'],
      ['STR', String(s.str||0)],
      ['DEX', String(s.dex||0)],
      ['INT', String(s.int||0)],
      ['SEN', String(s.sen||0)],
      ['CON', String(s.con||0)],
    ];
    charStats.innerHTML = lines.map(([k,v])=>`<div class="chip" style="display:flex;justify-content:space-between"><span>${k}</span><b>${v}</b></div>`).join('');
    charWin.style.display='block';
  }
  function closeCharacter(){ if(charWin) charWin.style.display='none'; }
  if(charClose) charClose.onclick = closeCharacter;

  function ensureJobGuideEl(){
    if(jobGuideWin) return jobGuideWin;
    jobGuideWin = document.createElement('div');
    jobGuideWin.className='window';
    jobGuideWin.style.display='none';
    jobGuideWin.innerHTML = `
      <button class="close" id="jobGuideClose">‚úï</button>
      <h2>Jobs Guide</h2>
      <div class="list">
        <div class="item"><b>Choose your path at Lv 10</b><div style="opacity:.8; font-size:12px; margin-top:4px">Hawker ¬∑ Dealer ¬∑ Soldier ¬∑ Muse. Visit the Trainer (‚òÖ) to start your job quest.</div></div>
        <div class="item">Press <b>E</b> near the Trainer to talk. Follow the on-screen arrows to find them.</div>
      </div>`;
    document.getElementById('game-wrap').appendChild(jobGuideWin);
    jobGuideWin.querySelector('#jobGuideClose').onclick = ()=>{ jobGuideWin.style.display='none'; jobArrow.active=false; };
    return jobGuideWin;
  }

  let jobArrow = {active:false};
  function openJobGuide(){ ensureJobGuideEl(); jobGuideWin.style.display='block'; jobArrow.active=true; }

  function openSkills(){
    const s = player.stats || (player.stats={str:0,dex:0,int:0,sen:0,con:0});
    statsList.innerHTML = '';
    const pts = player.statPoints|0;
    const header=document.createElement('div'); header.className='item'; header.innerHTML = `<b>Points Available</b> <span class="pill">${pts}</span> <span class="pill">Lv ${player.level}/${MAX_LEVEL}</span>`; statsList.appendChild(header); statsList.appendChild(document.createElement('div'));
    const mkRow=(label,key,desc)=>{ const wrap=document.createElement('div'); wrap.className='item'; wrap.innerHTML=`<b>${label}</b> <span class=\"pill\">${s[key]}</span> <span class=\"pill\" style=\"opacity:.8\">${desc}</span>`; const actions=document.createElement('div'); const plus=document.createElement('button'); plus.textContent='+1'; plus.disabled = (player.statPoints|0) <= 0; plus.onclick=()=>{ if(player.statPoints>0){ s[key]++; player.statPoints--; recalcStats(); save(); openSkills(); } }; actions.appendChild(plus); statsList.appendChild(wrap); statsList.appendChild(actions); };
    mkRow('STR','str','Attack Power');
    mkRow('DEX','dex','Movement/Attack Speed');
    mkRow('INT','int','Magic Power');
    mkRow('SEN','sen','Critical & Luck');
    mkRow('CON','con','Accuracy');
    statsWin.style.display='block';
  }

  // Skills
  const SKILL_DB={
    Visitor:[
      {id:'roll', name:'Quick Step', icon:'üåÄ', cd:6, mp:8, use:()=>dash(160), desc:'Dash forward quickly to evade danger.', req:{wep:null}},
      {id:'bomb', name:'Pebble Toss', icon:'ü™®', cd:4, mp:6, use:()=>shootCone(3,50,0.6), desc:'Toss a spread of pebbles in a cone.', req:{wep:null}}
    ],
    Soldier:[
      {id:'slash', name:'Power Slash', icon:'‚öîÔ∏è', cd:5, mp:12, use:()=>arcStrike(70,1.4), desc:'A heavy melee slash.', req:{wep:'sword'}},
      {id:'whirl', name:'Whirlwind', icon:'üåÄ', cd:10, mp:16, use:()=>spinAoE(90,0.7), desc:'Spin and strike all around.', req:{wep:'sword'}},
      {id:'berserk', name:'Berserk', icon:'üî•', cd:20, mp:0, use:()=>{ player.buffs.push({aspd:0.75, atk:6, t:10}); notify('Berserk!'); }, desc:'Increase ASPD and ATK for a short time.', req:{wep:null}}
    ],
    Hawker:[
      {id:'dbl', name:'Double Shot', icon:'üéØ', cd:4, mp:10, use:()=>multiShot(2,10), desc:'Fire two quick shots.', req:{wep:'bow'}},
      {id:'flurry', name:'Flurry', icon:'ü•∑', cd:7, mp:12, use:()=>arcStrike(60,2.0,3), desc:'Rapid melee strikes.', req:{wep:'katar'}},
      {id:'haste', name:'Haste', icon:'üí®', cd:22, mp:0, use:()=>{ player.buffs.push({speed:120, t:10}); notify('Haste up!'); }, desc:'Greatly increases movement speed.', req:{wep:null}}
    ],
    Muse:[
      {id:'bolt', name:'Mana Bolt', icon:'‚ú®', cd:2.6, mp:10, use:()=>magicBolt(1.2), desc:'Fire a concentrated mana bolt.', req:{wep:'wand'}},
      {id:'heal', name:'Heal', icon:'‚ûï', cd:6, mp:14, use:()=>{ player.hp=clamp(player.hp+50,0,player.hpMax); notify('Healed'); }, desc:'Restore HP.', req:{wep:null}},
      {id:'haste', name:'Haste', icon:'üí®', cd:20, mp:10, use:()=>{ player.buffs.push({speed:140, t:10}); notify('Haste up!'); }, desc:'Boost movement speed.', req:{wep:null}}
    ],
    Dealer:[
      {id:'nade', name:'Grenade', icon:'üí£', cd:6, mp:10, use:()=>grenade(), desc:'Lob a grenade that explodes.', req:{wep:null}},
      {id:'turret', name:'Auto-Turret', icon:'üîß', cd:14, mp:18, use:()=>deployTurret(), desc:'Deploy a temporary turret.', req:{wep:null}}
    ]
  };
  // QoL: Reset Stats item and handler
  ITEM_DB.reset_scroll = { name:'Reset Scroll', type:'consumable', price: 60, desc:'Refunds all spent stat points' };
  SHOP_STOCK_BASE.push('reset_scroll');
  function useItem(index){
    const entry=player.inv[index]; if(!entry) return; const it=ITEM_DB[entry.id]; if(!it) return;
    if(it.type==='consumable'){
      if(entry.id==='reset_scroll'){
        const spent = (player.stats.str|0)+(player.stats.dex|0)+(player.stats.int|0)+(player.stats.sen|0)+(player.stats.con|0);
        player.statPoints = (player.statPoints|0) + spent;
        player.stats={str:0,dex:0,int:0,sen:0,con:0};
        notify('Stats reset');
      } else if(it.hp||it.mp){ if(it.hp) player.hp=Math.min(player.hpMax, player.hp+it.hp); if(it.mp) player.mp=Math.min(player.mpMax, player.mp+it.mp); }
      if(entry.stack){ entry.stack--; if(entry.stack<=0) player.inv.splice(index,1); }
      else player.inv.splice(index,1);
      recalcStats(); save(); notify('Used '+it.name);
    } else if(it.type==='vehicle'){
      player.hasCartPass=true; player.flags.cartUnlocked=true; player.inv.splice(index,1); notify('Cart License acquired (press C to summon)'); save();
    }
    renderInventory();
  }

  function setSkillsForJob(job){
    const defs=SKILL_DB[job]||SKILL_DB['Visitor'];
    for(let i=0;i<4;i++){
      player.skills[i]=defs[i]||null; player.skillCd[i]=0;
      sicons[i].textContent = defs[i]? defs[i].icon:'‚Äî'; scds[i].style.display='none';
      if(defs[i]){ const tip = defs[i].desc? `${defs[i].name} ‚Äî ${defs[i].desc}${defs[i].req&&defs[i].req.wep? ` (Req: ${defs[i].req.wep})`:''}` : defs[i].name; const slotEl = document.querySelector(`.hotbar .slot[data-s="${i}"]`); if(slotEl) slotEl.title = tip; }
    }
    // Remove skill from slot 2; all non-weapon AOEs locked until Lv 10
    player.skills[1] = null; sicons[1].textContent='‚Äî'; const slot2=document.querySelector('.hotbar .slot[data-s="1"]'); if(slot2) slot2.title='Locked until Lv 10';
  }

  // Simple refine system (Smith)
  function openRefineWindow(){
    const win=document.createElement('div'); win.className='window'; win.style.display='block'; win.innerHTML=`<button class="close">‚úï</button><h2>Smith ‚Äî Refine</h2><div class="list" id="refineList"></div>`; document.getElementById('game-wrap').appendChild(win);
    const list = win.querySelector('#refineList');
    const close = win.querySelector('.close'); close.onclick=()=>{ win.remove(); };
    // list gear from inventory and equipped
    const candidates=[];
    for(const [slot,id] of Object.entries(player.eq)){ if(id) candidates.push({id, equipped:true, slot}); }
    player.inv.forEach((e,i)=>{ const it=ITEM_DB[e.id]; if(it && it.type==='gear' && it.slot!=='gem') candidates.push({id:e.id, index:i}); });
    candidates.forEach(c=>{
      const it=ITEM_DB[c.id]; const div=document.createElement('div'); div.className='item';
      const lvl = (it.refine|0);
      const price = Math.max(20, (it.price||80)) * (1+lvl) ;
      const rate = Math.max(0.55 - lvl*0.05, 0.15); // lower at higher levels
      div.innerHTML = `<b>${it.name}${lvl? ' +'+lvl:''}</b> <span class="pill">${price}‚ú¶</span> <span class="pill">${Math.round(rate*100)}% success</span>`;
      const actions=document.createElement('div'); const btn=document.createElement('button'); btn.textContent='Refine'; btn.onclick=()=>{
        if((player.gold|0) < price){ notify('Not enough gold'); return; }
        player.gold -= price;
        if(Math.random() < rate){
          it.refine = (it.refine|0) + 1; // store level on item def for simplicity
          // apply bonuses multiplicatively to base stats on equip calc
          notify('Refine success!');
        } else {
          if(it.refine>4 && Math.random()<0.35){ it.refine--; notify('Refine failed and dropped a level'); } else { notify('Refine failed'); }
        }
        goldEl.textContent = player.gold|0; shopGold.textContent=player.gold|0; recalcStats(); save(); openRefineWindow(); win.remove();
      };
      actions.appendChild(btn); list.appendChild(div); list.appendChild(actions);
    });
  }

  // Socketing window for gems (weapon, armor, wings, shield)
  function openSocketWindow(invIndex){
    const entry = player.inv[invIndex]; if(!entry) return; const gem = ITEM_DB[entry.id]; if(!gem || gem.slot!=='gem') return;
    const targets = [
      {slot:'weapon', name:'Weapon', id: player.eq.weapon || (player.inv.find(e=> ITEM_DB[e.id]?.slot==='weapon')?.id)},
      {slot:'armor',  name:'Armor',  id: player.eq.armor  || (player.inv.find(e=> ITEM_DB[e.id]?.slot==='armor')?.id)},
      {slot:'wings',  name:'Wings',  id: player.eq.wings  || (player.inv.find(e=> ITEM_DB[e.id]?.slot==='wings')?.id)},
      {slot:'shield', name:'Shield', id: player.eq.shield || (player.inv.find(e=> ITEM_DB[e.id]?.slot==='shield')?.id)}
    ].filter(t=>t.id);
    if(!targets.length){ notify('No gear to socket. Equip or carry gear first.'); return; }
    const win=document.createElement('div'); win.className='window'; win.style.display='block'; win.innerHTML=`<button class=\"close\">‚úï</button><h2>Socket Gem</h2><div class=\"list\" id=\"sockList\"></div>`; document.getElementById('game-wrap').appendChild(win);
    const list = win.querySelector('#sockList'); const close = win.querySelector('.close'); close.onclick=()=>win.remove();
    targets.forEach(t=>{
      const it = ITEM_DB[t.id]; const div=document.createElement('div'); div.className='item';
      const icon = getItemIconSVG(t.id);
      div.innerHTML = `<div style=\"display:flex;align-items:center\"><span class=\"icon\">${icon}</span><div><b>${it.name}</b> <span class=\"pill\">${t.name}</span><div style=\"font-size:12px;opacity:.85;margin-top:4px\">Current Gem: ${it.socket? ITEM_DB[it.socket].name : 'None'}</div></div></div>`;
      const actions=document.createElement('div'); const btn=document.createElement('button'); btn.textContent='Socket'; btn.onclick=()=>{
        // Ensure equipped; if not, auto-equip from inventory
        if(!player.eq[t.slot]){
          const idx = player.inv.findIndex(e=> ITEM_DB[e.id]?.slot===t.slot);
          if(idx>=0){ player.eq[t.slot] = player.inv[idx].id; player.inv.splice(idx,1); }
        }
        if(player.eq[t.slot]) ITEM_DB[player.eq[t.slot]].socket = entry.id;
        if(entry.stack){ entry.stack--; if(entry.stack<=0) player.inv.splice(invIndex,1); }
        else player.inv.splice(invIndex,1);
        notify(`Gem socketed into ${t.name}`); recalcStats(); save(); renderInventory(); win.remove();
      };
      actions.appendChild(btn); list.appendChild(div); list.appendChild(actions);
    });
  }

  function tryUseSkill(slot){
    const s = player.skills[slot]; if(!s) return notify('No skill in slot '+(slot+1));
    if(player.skillCd[slot]>0) return;
    if(player.level < 10 && !s.unlockedBelow10){ notify('Skills unlock at Lv 10. Keep leveling!'); return; }
    // Weapon requirement check
    if(s.req && s.req.wep){ const wepType=getEquippedWeaponType(); if(wepType!==s.req.wep){ notify(`${s.name} requires a ${s.req.wep.toUpperCase()}`); return; } }
    if(player.mp < s.mp) return notify('Not enough MP');
    player.mp-=s.mp;
    // Simple synergy: Poisoned targets take +20% from Flurry
    const hadPoison = player.buffs.some(b=>b.poisonTag);
    s.use();
    if(s.id==='flurry' && hadPoison){
      for(const m of ents){ if(!m.alive) continue; if(dist(player.x,player.y,m.x,m.y)<70){ const out=calcDamage(player.atk*0.2,'physical'); m.hp-=out.dmg; showDamage(m.x,m.y,out.dmg,out.crit,'physical'); if(m.hp<=0){ m.alive=false; onMobKilled(m);} } }
    }
    player.skillCd[slot]=s.cd; scds[slot].style.display='grid';
  }

  // Stat scaling (STR/DEX/INT/SEN/CON)
  (function(){
    const _recalc = recalcStats;
    recalcStats = function(){
      _recalc();
      const s = player.stats || (player.stats = {str:0,dex:0,int:0,sen:0,con:0});
      // STR: baseline physical power
      player.atk = Math.round(player.atk + (s.str||0) * 1.0);
      // DEX: movement speed bonus (stronger scaling)
      player.speed += (s.dex||0) * 3.5;
      // INT: applied in calcDamage for magic damage only
      // SEN: applied in calcDamage as crit chance
      // CON: affects accuracy via rollHitAgainst()
      if(player.hp>player.hpMax) player.hp=player.hpMax;
    };
  })();

  // Combat helpers: damage calc and floating numbers
  function calcDamage(base, kind){
    const s = player.stats || (player.stats={str:0,dex:0,int:0,sen:0,con:0});
    // include gem passive bonuses in calc realtime (non-persistent)
    if(player.eq.gem){ const g=ITEM_DB[player.eq.gem]; if(g && g.bonus){
      const b=g.bonus; if(b.str) base += b.str*1.0; // physical power boost via STR
    } }
    let dmg = base;
    if(kind==='magic') dmg += (s.int||0) * 1.2;
    let crit = false;
    const chance = Math.min(0.7, 0.05 + 0.01 * (s.sen||0) + (player.critBonus||0));
    if(Math.random() < chance){ crit = true; dmg *= 1.75; }
    return { dmg: Math.max(1, Math.round(dmg)), crit };
  }
  function rollHitAgainst(target){
    // Accuracy is a derived stat now (acc)
    let base = player.acc || 0.78;
    if(player.eq.gem){ const g=ITEM_DB[player.eq.gem]; if(g && g.bonus && g.bonus.con){ base += 0.015 * g.bonus.con; } }
    const evasion = clamp(((target.speed||80) - 80) / 400, -0.05, 0.15); // -5%..+15%
    const chance = clamp(base - evasion, 0.05, 0.98);
    return Math.random() < chance;
  }
  function showMiss(x,y){ fx.push({t:0.8, kind:'miss', x, y}); }
  function showDamage(x,y,amount,isCrit, dtype){ fx.push({t:1.1, kind:'dmg', x, y, val:amount, crit:isCrit, dtype}); fx.push({t:0.18, kind:'hit', x, y}); Sfx.play('hit'); }

  // Skill helpers
  function dash(len){ const a=player.dir; player.x+=Math.cos(a)*len; player.y+=Math.sin(a)*len; fx.push({t:0.3, kind:'dash', x:player.x, y:player.y}); }
  // Weapon AOE supers (slot 1/2 hotbar)
  function superWhirlwind(){
    const radius = 120; const duration=0.9; const spins=8;
    for(let i=0;i<spins;i++){
      setTimeout(()=>{ arcStrike(radius, 1.1, 1); fx.push({t:0.25, kind:'whirl', x:player.x, y:player.y, r:radius}); vibrate(12); Sfx.play('slash'); }, i*(duration*1000/spins));
    }
  }
  function superWindstorm(){
    const radius = 160; const ticks=6; const tickMs=160; let angle=0;
    for(let i=0;i<ticks;i++){
      setTimeout(()=>{
        angle += Math.PI/3;
        // Freeze + damage
        for(const m of ents){ if(!m.alive) continue; const d=dist(player.x,player.y,m.x,m.y); if(d<radius){ const out=calcDamage(player.atk*1.1,'magic'); m.hp-=out.dmg; showDamage(m.x,m.y,out.dmg,out.crit,'magic'); m.hurt=0.2; m.speed = Math.max(20, (m.speed||90)*0.35); if(m.hp<=0){ m.alive=false; onMobKilled(m);} }
        }
        fx.push({t:0.22, kind:'wind', x:player.x, y:player.y, r:radius, a:angle}); vibrate(10); Sfx.play('cast');
      }, i*tickMs);
    }
  }
  function superBowVolley(){
    const n=16; const spread=360; for(let i=0;i<n;i++){ const a=(i/n)*Math.PI*2; shoot(player.x,player.y,a, player.atk*0.75, player.projSpeed+60, 'player'); }
    fx.push({t:0.28, kind:'burst', x:player.x, y:player.y, r:120});
  }
  function superKatarFlurry(){
    for(let i=0;i<5;i++){ setTimeout(()=>{ arcStrike(70, 1.2, 3, 8); fx.push({t:0.22, kind:'slash', x:player.x, y:player.y, a:getAimDir(), r:86}); vibrate(8); }, i*90); }
  }
  function superGunShockwave(){
    // Bullet Storm: radial bullet sprays in waves
    const waves=5; const bulletsPerWave=44; const speedBase = player.projSpeed+120; const dmgBase = player.atk*0.75;
    for(let w=0; w<waves; w++){
      setTimeout(()=>{
        const jitter = Math.random()*Math.PI*2;
        for(let i=0;i<bulletsPerWave;i++){
          const a = jitter + (i/bulletsPerWave)*Math.PI*2 + (Math.random()*0.18-0.09);
          const sp = speedBase + (Math.random()*80-40);
          shoot(player.x,player.y,a, dmgBase, sp, 'player', 'bullet');
        }
        fx.push({t:0.22, kind:'spray', x:player.x, y:player.y, r:140});
        Sfx.play('gun');
      }, w*120);
    }
  }
  function superWandNova(){
    const n=28; for(let i=0;i<n;i++){ const a=(i/n)*Math.PI*2; shoot(player.x,player.y,a, player.atk*0.85+8, player.projSpeed+30, 'player','magic'); }
    fx.push({t:0.3, kind:'nova', x:player.x, y:player.y, r:150}); Sfx.play('cast');
  }
  function arcStrike(radius, mult=1.0, swings=1, step=0){
    const base = player.atk*mult; const a0=getAimDir(); for(let k=0;k<swings;k++){
      setTimeout(()=>{
        // slight lunge forward for tactile melee
        if(step>0){ const nx = player.x + Math.cos(a0)*step; const ny = player.y + Math.sin(a0)*step; if(!blocked(nx, player.y)) player.x = nx; if(!blocked(player.x, ny)) player.y = ny; }
        for(const m of ents){ if(!m.alive) continue; const a=Math.atan2(m.y-player.y,m.x-player.x); let da=Math.atan2(Math.sin(a-a0),Math.cos(a-a0)); const extra = Math.min(14, (m.r||18)*0.6); if(Math.abs(da)<1.0 && dist(player.x,player.y,m.x,m.y)<(radius+extra)){ if(rollHitAgainst(m)){ const out=calcDamage(base,'physical'); m.hp-=out.dmg; showDamage(m.x,m.y,out.dmg,out.crit,'physical'); m.hurt=0.12; if(m.hp<=0){ m.alive=false; onMobKilled(m);} } else { showMiss(m.x,m.y); } }
        }
        fx.push({t:0.18, kind:'arc', x:player.x, y:player.y, a:a0, r:radius});
        fx.push({t:0.22, kind:'slash', x:player.x, y:player.y, a:a0, r:radius});
        player.swingT = 0.3;
      }, k*90);
    }
  }
  function spinAoE(radius, dur){ const hits=6; for(let i=0;i<hits;i++){ setTimeout(()=>arcStrike(radius,0.8), i*(dur*1000/hits)); } }
  function shootCone(n, spreadDeg, mult){ for(let i=0;i<n;i++){ const a=player.dir + ((i-(n-1)/2)*spreadDeg*Math.PI/180); shoot(player.x,player.y,a,player.atk*(mult||0.6), player.projSpeed+30,'player'); } }
  function multiShot(n, spread){ for(let i=0;i<n;i++){ const a=player.dir + ((i-(n-1)/2)*spread*Math.PI/180); shoot(player.x,player.y,a,player.atk*0.9, player.projSpeed+40,'player'); } }
  function magicBolt(mult){ shoot(player.x,player.y,player.dir, player.atk*mult+6, player.projSpeed+10,'player','magic'); }
  function grenade(){ const a=player.dir; const speed=280; projs.push({x:player.x,y:player.y,vx:Math.cos(a)*speed,vy:Math.sin(a)*speed, dmg:0, ttl:0.7, owner:'player', kind:'lob', onExpire:(px,py)=>{ // explode
      for(const m of ents){ if(!m.alive) continue; if(dist(px,py,m.x,m.y)<90){ const out=calcDamage(player.atk*1.2,'physical'); m.hp-=out.dmg; showDamage(m.x,m.y,out.dmg,out.crit); m.hurt=0.2; if(m.hp<=0){ m.alive=false; onMobKilled(m);} }
      }
      fx.push({t:0.35, kind:'boom', x:px,y:py});
    }});
  }
  function deployTurret(){ const a=player.dir; const x=player.x+Math.cos(a)*40, y=player.y+Math.sin(a)*40; const t={x,y,t:8}; turrets.push(t); notify('Turret deployed'); }

  // ==== SECTION: MOB TYPE NORMALIZER (Flaenae alias) ====
  function normalizeType(t){
    if(!t) return t;
    const k = String(t).toLowerCase();
    if(k==='flaenae' || k==='flaenae '|| k==='flaena' ) return 'flanae';
    return t;
  }

  // Enemies
  function spawnMob(type,x,y){
    type = normalizeType(type);
    const base = {kind:'mob', type, x, y, r:18, speed:90, hp:40, hpMax:40, atk:8, alive:true, hurt:0, aggro:0, mcd:0};
    if(type==='jelly'){ Object.assign(base,{
      r:19,speed:64,hp:35,hpMax:35,atk:6,
      // Hopping bean physics and presentation (smoother cadence)
      z:0, vz:0, hopCd:Math.random()*0.9 + 1.9, squash:0, stretch:0,
      vx:0, vy:0,
      seed:(Math.random()*1000)|0,
      // ROSE-like green jelly bean base color
      col:'#68c64f'
    }); }
    if(type==='pumpkin'){ Object.assign(base,{r:19,speed:70,hp:70,hpMax:70,atk:10}); }
    if(type==='flanae'){ Object.assign(base,{r:18,speed:120,hp:45,hpMax:45,atk:8, flyer:true}); }
    if(type==='jellyking'){ Object.assign(base,{r:28,speed:80,hp:360,hpMax:360,atk:14, boss:true,
      z:0, vz:0, hopCd:Math.random()*1.0 + 1.0, squash:0, stretch:0, vx:0, vy:0, seed:(Math.random()*1000)|0, col:'#f35ac9'
    }); }
    if(type==='moldy'){ Object.assign(base,{r:20,speed:70,hp:120,hpMax:120,atk:16}); }
    if(type==='moldy_elite'){ Object.assign(base,{r:22,speed:80,hp:220,hpMax:220,atk:24}); }
    if(type==='rockgolem'){ Object.assign(base,{r:26,speed:60,hp:420,hpMax:420,atk:30, golem:true}); }
    if(type==='choropy'){ Object.assign(base,{r:18,speed:130,hp:60,hpMax:60,atk:10}); }
    if(type==='woopie'){ Object.assign(base,{r:20,speed:100,hp:80,hpMax:80,atk:12}); }
    if(type==='gorge_beetle'){ Object.assign(base,{r:16,speed:120,hp:140,hpMax:140,atk:22}); }
    if(type==='luna_wolf'){ Object.assign(base,{r:20,speed:140,hp:200,hpMax:200,atk:26}); }
    if(type==='luna_spirit'){ Object.assign(base,{r:18,speed:90,hp:160,hpMax:160,atk:24, flyer:true}); }
    if(type==='spirit_archer'){ Object.assign(base,{r:18,speed:100,hp:260,hpMax:260,atk:28, ranged:true}); }
    if(type==='thornling'){ Object.assign(base,{r:20,speed:110,hp:300,hpMax:300,atk:30, dashy:true}); }
    if(type==='ancient_treant'){ Object.assign(base,{r:30,speed:65,hp:900,hpMax:900,atk:38, boss:true, treant:true}); }
    ents.push(base); return base;
  }

  // Populate mobs ‚Äî start gentle: only a handful of Jellies at first
  for(let i=0;i<24;i++){
    const t = 'jelly';
    const x = rand(TILE*8, TILE*(MAP_W-8));
    const y = rand(TILE*6, TILE*(MAP_H-6));
    if(dist(x,y,startPos.x,startPos.y)>TILE*10) spawnMob(t,x,y);
  }
  (function spawnBoss(){ let tries=0; while(tries++<50){ const x=rand(TILE*20, TILE*(MAP_W-12)); const y=rand(TILE*18, TILE*(MAP_H-12)); if(dist(x,y,startPos.x,startPos.y)>TILE*25){ spawnMob('jellyking',x,y); break; } }})();

    // NPCs
  const sign = {kind:'npc', npc:'sign', x:startPos.x+TILE*2.5, y:startPos.y- TILE*1.2, r:18};
  const merchant = {kind:'npc', npc:'merchant', x:startPos.x+TILE*5.5, y:startPos.y- TILE*0.3, r:22};
  const trainer = {kind:'npc', npc:'trainer', x:startPos.x+TILE*3.8, y:startPos.y+ TILE*0.4, r:22};
  // Plains no longer has Cart Master at start; keep variable for other maps if needed (set to null here)
  const cartMaster = null;
  const storageNPC = {kind:'npc', npc:'storage', x:startPos.x+TILE*6.8, y:startPos.y+ TILE*1.0, r:22};
    // Boat NPC in plains is static object; ferryJ is placed in genJunon

  // Quests ‚Äî Story progression + bounties
  const quests=[
    // Story: Plains intro ‚Üí Luxem travel ‚Üí Luxem kills ‚Üí Reach Lv10 for Zant ‚Üí Zant kills ‚Üí Reach Lv15 for Junon
    {id:0, title:'Meet the Plains', line:'Welcome! Interact with the wooden signpost.', need:0, type:'talk', done:false, reward:{xp:30,gold:40, items:[['potion_hp',2]]}},
    {id:0.5, title:'Basic Combat', line:'Defeat 5 Jelly Blobs to practice.', need:5, type:'jelly', prog:0, done:false, reward:{xp:50,gold:40}},
    {id:1, title:'Path to Luxem', line:'Find the portal (üåÄ) at the far left of Adventure Plains and travel to Luxem Forest.', need:1, type:'travel', to:'luxem', done:false, reward:{xp:60,gold:60}},
    {id:2, title:'Breezy Hunt', line:'In Luxem Forest, defeat 10 Choropys to learn the ropes.', need:10, type:'choropy', prog:0, done:false, reward:{xp:140,gold:120, items:[['potion_mp',2]]}},
    {id:2.5, title:"Herbalist's Pouch", line:'Fetch the lost pouch near the creek in Luxem. Return to the sign.', need:1, type:'fetch_pouch', prog:0, done:false, reward:{xp:120,gold:100}},
    {id:3, title:'Ready for Zant', line:"Reach Level 10. Then use Luxem's portal to travel to Zant.", need:10, type:'level', done:false, reward:{xp:200,gold:160}},
    {id:4, title:'Zant Skirmish', line:'Defeat 10 Woopies around the outskirts of Zant.', need:10, type:'woopie', prog:0, done:false, reward:{xp:240,gold:240}},
    {id:4.5, title:'Woopie Drums', line:'Defeat the Elite Woopie drummer near Zant.', need:1, type:'woopie_elite', prog:0, done:false, reward:{xp:260,gold:260, items:[['ring_silver',1]]}},
    {id:5, title:'March to Junon', line:'Reach Level 15. Travel onward through El Verloon Desert to Junon Polis.', need:15, type:'level', done:false, reward:{xp:320,gold:320}},
    {id:5.5, title:'Golem Core', line:'Hunt the Golem Mini-Boss and bring back its core.', need:1, type:'golem_core', prog:0, done:false, reward:{xp:380,gold:360, items:[['s7',1]]}},
    {id:6, title:'Gate Trial', line:'Complete the city gate trial waves in Junon.', need:1, type:'gate_trial', prog:0, done:false, reward:{xp:420,gold:380}},
    // Late-game arc: Luna ‚Üí Eldeon
    {id:40, title:'Arrival: Eldeon', line:'Travel from Luna to Eldeon Glade.', need:1, type:'travel', to:'eldeon', done:false, reward:{xp:600,gold:500}},
    {id:41, title:'Eldeon Hunt', line:'Defeat 10 Eldeon foes (Spirit Archers or Thornlings).', need:10, type:'eldeon_kill', prog:0, done:false, reward:{xp:800,gold:700}},
    {id:42, title:'Eldeon Guardian', line:'Defeat the Ancient Treant guarding the glade.', need:1, type:'ancient_treant', prog:0, done:false, reward:{xp:1200,gold:900, items:[['cloak_royal',1]]}},
    // Bounties (optional, light repeatables)
    {id:10, title:'Zant Bounty: Choropy', line:'Defeat 12 Choropys around Luxem and Zant outskirts.', need:12, type:'choropy', prog:0, done:false, reward:{xp:260,gold:240}},
    {id:11, title:'Junon Bounty: Moldy', line:'Defeat 10 Moldy Spores near the city.', need:10, type:'moldy', prog:0, done:false, reward:{xp:340,gold:300}},
    {id:12, title:'El Verloon Bounty: Golems', line:'Defeat 6 Rock Golems in the dunes.', need:6, type:'rockgolem', prog:0, done:false, reward:{xp:520,gold:420}}
  ];
  let qIndex=0;

  // Cart subquest state (patch 3 spec)
  const cartQuest = {active:false, paid:false, fee:20, pumpkins:0, needPumpkins:10};
  player.flags = player.flags || {}; // holds cartUnlocked

  function xpFor(level){ if(level>=MAX_LEVEL) return Infinity; return Math.floor(50 * Math.pow(level, 1.5)); }

  // Input
  const keys={};
  addEventListener('keydown', e=>{ const k=e.key.toLowerCase(); keys[k]=true; if(e.key===' '){e.preventDefault();}
    if(e.altKey && ((e.key==='S'||k==='s') || (e.key==='A'||k==='a'))){ if(typeof openSkills==='function') openSkills(); }
    if(e.altKey && (e.key==='M' || k==='m')){ if(shopWin.style.display==='block'){ shopWin.style.display='none'; } else { openShop(); } }
    // Alt+L previously opened Storage; keep as is for now (Trainer change is Plains NPC only)
    if(e.altKey && (e.key==='J' || k==='j')){ openJobGuide(); }
    if(e.altKey && (e.key==='C' || k==='c')){ if(charWin && charWin.style.display==='block'){ closeCharacter(); } else { openCharacter(); } }
    if(e.altKey && (e.key==='P' || k==='p')){ openParty(); }
    if(e.altKey && (e.key==='F' || k==='f')){ openFriends(); }
    if(e.altKey && (e.key==='T' || k==='t')){ TTS_ENABLED=!TTS_ENABLED; saveTTS(); notify('TTS '+(TTS_ENABLED?'ON':'OFF')); }
    if(k==='i'){ openInventory(); }
    if(k==='m'){ if(nearest(merchant) < TILE*1.8) openShop(); else notify('Find the Merchant (üõí)'); }
    if(k==='j'){ if(nearest(trainer) < TILE*1.8) openJobs(); else notify('Find the Trainer (‚òÖ)'); }
    if(k==='1') tryUseSkill(0); if(k==='2') tryUseSkill(1); if(k==='3') tryUseSkill(2); if(k==='4') tryUseSkill(3);
    if(k==='c'){ if(player.flags.cartUnlocked){ toggleSummonCart(); } else notify('Finish Cart License first.'); }
  });
  addEventListener('keyup',   e=>{ keys[e.key.toLowerCase()]=false; });

  let mouse={x:0,y:0, down:false};
  canvas.addEventListener('mousemove', e=>{ const rect=canvas.getBoundingClientRect(); mouse.x=(e.clientX-rect.left)*DPR; mouse.y=(e.clientY-rect.top)*DPR; });
  addEventListener('mousedown', ()=>mouse.down=true);
  addEventListener('mouseup', ()=>mouse.down=false);

  // Touch joystick
  let joy={active:false, ox:0, oy:0, dx:0, dy:0};
  stick.addEventListener('touchstart', e=>{e.preventDefault(); joy.active=true; const p=stick.getBoundingClientRect(); joy.ox=p.left+p.width/2; joy.oy=p.top+p.height/2; });
  stick.addEventListener('touchmove',  e=>{e.preventDefault(); if(!joy.active) return; const t=e.touches[0]; let dx=t.clientX-joy.ox, dy=t.clientY-joy.oy; const m=Math.hypot(dx,dy); const max=50; if(m>max){ dx=dx/m*max; dy=dy/m*max; } knob.style.transform=`translate(${dx}px, ${dy}px)`; joy.dx=dx/max; joy.dy=dy/max; });
  stick.addEventListener('touchend',   e=>{e.preventDefault(); joy.active=false; knob.style.transform='translate(-50%,-50%)'; joy.dx=joy.dy=0;});
  atkBtn.addEventListener('touchstart', e=>{e.preventDefault(); mouse.down=true;});
  atkBtn.addEventListener('touchend',   e=>{e.preventDefault(); mouse.down=false;});

  // UI Buttons
  el('newgame').onclick=()=>{ hideOverlay(); showCreate(); }; 
  // Character creation controls
  const ccStartBtn = el('cc-start');
  const ccBackBtn  = el('cc-back');
  if(ccStartBtn){ ccStartBtn.onclick = ()=>{ startNew(); }; }
  if(ccBackBtn){ ccBackBtn.onclick = ()=>{ hideCreate(); showOverlay(); }; }
  el('continue').onclick=()=>{ if(load()) { hideOverlay(); recalcStats(); setSkillsForJob(player.job); } else { startNew(); hideOverlay(); } };
  el('erase').onclick=()=>{ erase(); notify('Save erased'); };
  function hideOverlay(){ overlay.style.display='none'; }
  function showOverlay(){ overlay.style.display='grid'; }
  function showCreate(){
    createOv.style.display='grid';
    initCCPreview();
    drawCCPreview();
    // Sync preview to current input defaults
    if(ccOutfit) ccOutfit.oninput = drawCCPreview;
    if(ccHair)   ccHair.oninput   = drawCCPreview;
    if(ccSkin)   ccSkin.oninput   = drawCCPreview;
    if(ccWings)  ccWings.onchange = drawCCPreview;
  }
  function hideCreate(){ createOv.style.display='none'; }

  // Character select flow removed

  function notify(msg){ toast.textContent=msg; toast.style.display='block'; clearTimeout(notify.t); notify.t=setTimeout(()=>toast.style.display='none', 1800); }
  function vibrate(ms){ if(navigator.vibrate) navigator.vibrate(ms); }

  function startNew(){
    player = makePlayer();
    player.stats = {str:0,dex:0,int:0,sen:0};
    player.statPoints = 5;
    // Character creation selections
    if(typeof ccName!=='undefined'){
      const nm = (ccName.value||'').trim(); player.name = nm? nm : 'Rosarian';
      player.appearance.outfit = ccOutfit.value||'#2a6aa8';
      player.appearance.hair = ccHair.value||'#3a2a1a';
      player.appearance.skin = ccSkin.value||'#f2d6c2';
      player.appearance.wingsStyle = (ccWings.value||'butterfly');
      // Map style to an item id for the starting equip (null for none)
      const style = player.appearance.wingsStyle;
      player.eq.wings = (
        style==='angel'      ? 'angel_wings' :
        style==='butterfly'  ? 'butterfly_wings' :
        style==='bat'        ? 'bat_wings' :
        style==='feather'    ? 'feather_wings' :
        style==='mechanical' ? 'mechanical_wings' :
        style==='fairy'      ? 'fairy_wings' :
        null
      );
      // Starting weapon selection
      const choice = ccWeaponSel? ccWeaponSel.value : 'wood_sword';
      // Auto-equip chosen starter gear instead of placing in inventory
      if(choice==='wood_sword_shield'){
        player.eq.weapon = 'wood_sword';
        player.eq.shield = 'wood_shield';
      } else {
        player.eq.weapon = choice;
      }
    }
    recalcStats(); setSkillsForJob(player.job);
    qIndex=0; quests.forEach(q=>{q.prog=0; q.done=false;}); cartQuest.active=false; cartQuest.paid=false; cartQuest.pumpkins=0;
    ents.length=0; projs.length=0; drops.length=0; turrets.length=0; fx.length=0; summonedCart=null;
    // default starter via CC, no extra weapon here
    // Wings handled via CC
    // New game: keep early area calm ‚Äî just a few Jellies to begin with
    for(let i=0;i<24;i++){
      const t = 'jelly';
      const x = rand(TILE*8, TILE*(MAP_W-8));
      const y = rand(TILE*6, TILE*(MAP_H-6));
      if(dist(x,y,startPos.x,startPos.y)>TILE*10) spawnMob(t,x,y);
    }
    (function spawnBoss(){ let tries=0; while(tries++<50){ const x=rand(TILE*20, TILE*(MAP_W-12)); const y=rand(TILE*18, TILE*(MAP_H-12)); if(dist(x,y,startPos.x,startPos.y)>TILE*25){ spawnMob('jellyking',x,y); break; } }})();
    mapName='plains'; genPlains(); saveMeta();
    save();
    hideCreate();
    openCharSelect();
  }

  // Character Creator live preview
  function initCCPreview(){
    if(!ccPreview) return;
    const dpi = Math.min(2, window.devicePixelRatio||1);
    const size = 360; ccPreview.width=size*dpi; ccPreview.height=size*dpi; ccPreview.style.imageRendering='pixelated';
    ccPreview.ctx = ccPreview.getContext('2d');
    // Bind inputs to redraw
    [ccOutfit, ccHair, ccSkin, ccWings, ccWeaponSel].forEach(inp=>{ if(inp){ inp.oninput = drawCCPreview; inp.onchange = drawCCPreview; } });
  }
  function drawCCPreview(){
    if(!ccPreview || !ccPreview.ctx) return;
    const ctxp = ccPreview.ctx; const w=ccPreview.width, h=ccPreview.height; const cx=w/2, cy=h*0.62;
    ctxp.clearRect(0,0,w,h);
    // Scene background: match in-game map style with a polished vignette
    const sky=ctxp.createLinearGradient(0,0,0,h*0.6); sky.addColorStop(0,'#0b1a24'); sky.addColorStop(1,'#0a1218'); ctxp.fillStyle=sky; ctxp.fillRect(0,0,w,h*0.55);
    const ground=ctxp.createLinearGradient(0,h*0.55,0,h); ground.addColorStop(0,'#5b3b22'); ground.addColorStop(1,'#2e1d12'); ctxp.fillStyle=ground; ctxp.fillRect(0,h*0.55,w,h);
    // Subtle bokeh lights
    ctxp.globalAlpha=0.35; ctxp.fillStyle='#27423e'; for(let i=0;i<24;i++){ const r=6+Math.random()*22; const x=Math.random()*w, y=Math.random()*h*0.55; ctxp.beginPath(); ctxp.arc(x,y,r,0,6.28); ctxp.fill(); } ctxp.globalAlpha=1;
    // Character simple render mirroring in-game palette
    const outfit = ccOutfit? ccOutfit.value : '#2a6aa8';
    const skin = ccSkin? ccSkin.value : '#f2d6c2';
    const wings = ccWings? ccWings.value : 'butterfly';
    const hair = ccHair? ccHair.value : '#3a2a1a';
    // Shadow
    ctxp.fillStyle='rgba(0,0,0,0.35)'; ctxp.beginPath(); ctxp.ellipse(cx, cy+16, 32, 16, 0, 0, 6.28); ctxp.fill();
    // Wings
    ctxp.save(); ctxp.translate(cx, cy);
    ctxp.globalAlpha=0.92;
    if(wings==='angel'){
      ctxp.fillStyle='rgba(240,245,255,0.95)';
      for(let i=0;i<3;i++){ ctxp.beginPath(); ctxp.ellipse(-30 - i*16, -6 - i*6, 28-i*4, 20-i*4, -0.4, 0, 6.28); ctxp.fill(); ctxp.beginPath(); ctxp.ellipse(-30 - i*16,  12 + i*6, 28-i*4, 20-i*4,  0.4, 0, 6.28); ctxp.fill(); }
      ctxp.strokeStyle='rgba(180,190,210,0.9)'; ctxp.lineWidth=2; ctxp.beginPath(); ctxp.moveTo(-20,-20); ctxp.lineTo(-80,0); ctxp.lineTo(-20,20); ctxp.stroke();
    } else if(wings==='bat'){
      ctxp.fillStyle='#4b2a4a'; ctxp.beginPath(); ctxp.moveTo(-18,-16); ctxp.quadraticCurveTo(-66,-10,-86,0); ctxp.quadraticCurveTo(-54,10,-18,18); ctxp.closePath(); ctxp.fill();
      ctxp.strokeStyle='rgba(0,0,0,0.5)'; ctxp.stroke();
    } else if(wings==='feather'){
      ctxp.fillStyle='#e8eef6'; for(let i=0;i<4;i++){ ctxp.beginPath(); ctxp.ellipse(-28 - i*14, 6 + i*6, 20, 12, 0.5, 0, 6.28); ctxp.fill(); }
      ctxp.strokeStyle='rgba(160,170,190,0.9)'; ctxp.lineWidth=2; ctxp.beginPath(); ctxp.moveTo(-20,-20); ctxp.lineTo(-80,2); ctxp.lineTo(-20,24); ctxp.stroke();
    } else if(wings==='mechanical'){
      ctxp.fillStyle='#667'; ctxp.beginPath(); ctxp.ellipse(-40,0,22,14,0.3,0,6.28); ctxp.fill(); ctxp.fillStyle='#889'; ctxp.beginPath(); ctxp.ellipse(-68,2,16,10,-0.2,0,6.28); ctxp.fill();
      ctxp.strokeStyle='#ccd'; ctxp.lineWidth=3; ctxp.beginPath(); ctxp.moveTo(-20,-14); ctxp.lineTo(-68,0); ctxp.lineTo(-20,14); ctxp.stroke();
    } else if(wings==='fairy'){
      ctxp.fillStyle='#aef'; ctxp.beginPath(); ctxp.ellipse(-36,-14,36,26,-0.6,0,6.28); ctxp.fill(); ctxp.fillStyle='#fb9'; ctxp.beginPath(); ctxp.ellipse(-66,10,28,20,0.6,0,6.28); ctxp.fill();
    } else if(wings==='butterfly'){
      ctxp.fillStyle='#ff9ad6'; ctxp.beginPath(); ctxp.ellipse(-36,-14,36,26,-0.6,0,6.28); ctxp.fill(); ctxp.beginPath(); ctxp.ellipse(-36,18,36,26,0.6,0,6.28); ctxp.fill();
      ctxp.fillStyle='#6cc9ff'; ctxp.beginPath(); ctxp.ellipse(-66,-6,28,20,-0.6,0,6.28); ctxp.fill(); ctxp.beginPath(); ctxp.ellipse(-66,10,28,20,0.6,0,6.28); ctxp.fill();
    }
    ctxp.restore();
    // Body
    const gBody = ctxp.createLinearGradient(cx-24, cy-40, cx+24, cy+20); gBody.addColorStop(0, outfit); gBody.addColorStop(1, '#13283d');
    ctxp.fillStyle=gBody; ctxp.beginPath(); ctxp.roundRect(cx-20, cy-28, 40, 56, 8); ctxp.fill();
    const gHead = ctxp.createRadialGradient(cx, cy-46, 4, cx, cy-42, 20); gHead.addColorStop(0,'#fff6'); gHead.addColorStop(1, skin);
    ctxp.fillStyle=gHead; ctxp.beginPath(); ctxp.arc(cx, cy-42, 16, 0, 6.28); ctxp.fill();
    // Hair cap
    ctxp.fillStyle=hair; ctxp.beginPath(); ctxp.arc(cx, cy-46, 12, Math.PI, 0); ctxp.fill();
    ctxp.fillRect(cx-12, cy-46, 24, 6);
    // Basic weapon preview in hand
    const wep = ccWeaponSel? ccWeaponSel.value : 'wood_sword';
    ctxp.save(); ctxp.translate(cx, cy); ctxp.rotate(-0.3);
    ctxp.fillStyle = '#d9d9d9';
    if(wep.includes('sword')){ ctxp.fillRect(10,-10,6,34); ctxp.fillRect(6,-8,14,4); }
    else if(wep.includes('bow')){ ctxp.strokeStyle='#cfa'; ctxp.lineWidth=4; ctxp.beginPath(); ctxp.moveTo(12,-18); ctxp.quadraticCurveTo(30,0,12,18); ctxp.stroke(); }
    else if(wep.includes('katar')){ ctxp.fillRect(8,-6,18,4); ctxp.fillRect(8,2,18,4); }
    else if(wep.includes('staff')){ ctxp.fillStyle='#b98f5a'; ctxp.fillRect(6,-24,8,46); }
    else if(wep.includes('wand')){ ctxp.fillStyle='#b98f5a'; ctxp.fillRect(10,-10,6,22); }
    ctxp.restore();
  }

  // Save/Load (use v2 key, fallback to v3 to not break old saves)
  const SAVE_KEY='ap-save-v2';
  const SAVE_FALLBACK='ap-save-v3';

  function save(){
    saveMeta();
    const data={p:{x:player.x,y:player.y,hp:player.hp,mp:player.mp,level:player.level,xp:player.xp,gold:player.gold,baseAtk:player.baseAtk,eq:player.eq,inv:player.inv,mounted:player.mounted,job:player.job,flags:player.flags,stats:player.stats,statPoints:player.statPoints,name:player.name,appearance:player.appearance,defBase:player.defBase,mdefBase:player.mdefBase}, q:quests.map(q=>({id:q.id,prog:q.prog,done:q.done})), idx:qIndex, cartQuest};
    localStorage.setItem(SAVE_KEY, JSON.stringify(data));
  }

  function load(){
    loadMeta();
    let s=localStorage.getItem(SAVE_KEY);
    if(!s){ s=localStorage.getItem(SAVE_FALLBACK); }
    if(!s) return false;
    try{
      const d=JSON.parse(s);
      player = Object.assign(makePlayer(), d.p||{});
      if(!player.flags) player.flags={};
      if(!player.stats) player.stats = {str:0,dex:0,int:0,sen:0};
      if(player.statPoints==null) player.statPoints = 0;
      player.name = player.name || 'Rosarian';
      player.appearance = player.appearance || {outfit:'#2a6aa8', hair:'#3a2a1a', skin:'#f2d6c2', wingsStyle:(player.eq && player.eq.wings)?'butterfly':'none'};
      quests.forEach(q=>{ const st=(d.q||[]).find(x=>x.id===q.id); if(st){ q.prog=st.prog||0; q.done=!!st.done; } else { q.prog=0; q.done=false; } });
      qIndex=d.idx||0; if(d.cartQuest){ Object.assign(cartQuest, d.cartQuest); }
      recalcStats(); setSkillsForJob(player.job||'Visitor');
      if(mapName==='junon'){ genJunon(); } else { genPlains(); }
      notify('Save loaded');
      return true;
    }catch(e){ console.warn('load failed', e); return false; }
  }

  function erase(){ localStorage.removeItem(SAVE_KEY); }

  // Helpers
  function worldToScreen(x,y){ return {x: Math.floor(x - camera.x), y: Math.floor(y - camera.y)}; }
  function tileAt(x,y){ const tx=Math.floor(x/TILE), ty=Math.floor(y/TILE); if(tx<0||ty<0||tx>=MAP_W||ty>=MAP_H) return 1; return tiles[ty*MAP_W+tx]; }
  function blocked(x,y){ return tileAt(x,y)===2; } // water blocks
  function nearest(obj){ return dist(player.x,player.y,obj.x,obj.y); }

  // Town guard helpers
  function isInTown(x,y){
    for(const z of townZones){
      if(z.type==='circle'){
        if(dist(x,y,z.x,z.y) <= z.r) return true;
      } else if(z.type==='rect'){
        if(x>=z.x && x<=z.x+z.w && y>=z.y && y<=z.y+z.h) return true;
      }
    }
    return false;
  }
  function pushOutOfTown(m){
    for(const z of townZones){
      if(z.type==='circle'){
        const dx = m.x - z.x, dy = m.y - z.y; const d = Math.hypot(dx,dy) || 1;
        if(d <= z.r){ const nx = dx/d, ny = dy/d; m.x = z.x + nx*(z.r+16); m.y = z.y + ny*(z.r+16); }
      } else if(z.type==='rect'){
        if(m.x>=z.x && m.x<=z.x+z.w && m.y>=z.y && m.y<=z.y+z.h){
          const left = m.x - z.x, right = (z.x+z.w) - m.x, top = m.y - z.y, bottom = (z.y+z.h) - m.y;
          const min = Math.min(left,right,top,bottom);
          if(min===left) m.x = z.x - 16; else if(min===right) m.x = z.x+z.w + 16; else if(min===top) m.y = z.y - 16; else m.y = z.y+z.h + 16;
        }
      }
    }
  }

  // ==== PATCH 5: Multi-map + ferry travel ====
  let mapName = 'plains';
  let transition = {a:0,to:null};

  // Removed boat travel NPCs in favor of portal-based progression
  // const harbor  = {kind:'npc', npc:'harbor', x: TILE*12.0, y: TILE*9.6,  r:26};
  // const ferryJ  = {kind:'npc', npc:'ferryJ', x: TILE*44.0, y: TILE*58.0, r:26};
  // let ferryCost = 60;

  const MAPS = {
    plains: { label:'Adventure Plains', gen: genPlains,  spawn:{main:{x: TILE*4, y: TILE*6}} },
    junon:  { label:'Junon Polis',      gen: genJunon,   spawn:{dock:{x: TILE*44, y: TILE*58}, gate:{x:TILE*20, y:TILE*28}} },
    zant:   { label:'Zant',             gen: genZant,    spawn:{plaza:{x:TILE*24, y:TILE*18}, gate:{x:TILE*10, y:TILE*34}} },
    elverloon:{ label:'El Verloon Desert', gen: genElVerloon, spawn:{oasis:{x:TILE*54, y:TILE*24}, dune:{x:TILE*18, y:TILE*48}} },
    luxem: { label:'Luxem Forest', gen: genLuxem, spawn:{grove:{x:TILE*28,y:TILE*22}, path:{x:TILE*10,y:TILE*36}} },
    canyon: { label:'Gorge Canyon', gen: genCanyon, spawn:{rim:{x:TILE*28,y:TILE*14}, basin:{x:TILE*52,y:TILE*48}} },
    luna: { label:'Luna', gen: genLuna, spawn:{landing:{x:TILE*22,y:TILE*20}, ridge:{x:TILE*40,y:TILE*36}} },
    eldeon: { label:'Eldeon Glade', gen: genEldeon, spawn:{grove:{x:TILE*24,y:TILE*20}, heart:{x:TILE*42,y:TILE*36}} }
  };

  function saveMeta(){ try{ localStorage.setItem('ap-meta', JSON.stringify({mapName})); }catch(e){} }
  function loadMeta(){ try{ const m=JSON.parse(localStorage.getItem('ap-meta')||'{}'); if(m.mapName) mapName=m.mapName; }catch(e){} }

  function drawTransitionOverlay(){
    if(!transition.to && transition.a<=0) return;
    if(transition.to){ transition.a += 0.06; if(transition.a>=1){
        const {next, spawnTag} = transition.to;
        mapName = next; softResetRuntime(); MAPS[mapName].gen(); ensureBaselineSpawns();
        const sp = MAPS[mapName].spawn[spawnTag] || Object.values(MAPS[mapName].spawn)[0];
        player.x = sp.x; player.y = sp.y; saveMeta(); transition.to=null;
        // Story quest auto-advancers for travel milestones
        const q = quests[qIndex];
        if(q && q.type==='travel'){
          const dest = q.to || '';
          if(dest === mapName){ q.done = true; notify('Quest updated: '+q.title); if(qIndex < quests.length-1) qIndex++; save(); }
        }
      }
    } else { transition.a -= 0.06; if(transition.a<0) transition.a=0; }
    ctx.save(); ctx.globalAlpha = Math.min(1,Math.max(0,transition.a)); ctx.fillStyle='#000'; ctx.fillRect(0,0,vw,vh); ctx.restore();
  }
  function changeMap(next, spawnTag='main'){ transition.to={next, spawnTag}; }

  function softResetRuntime(){ ents.length=0; projs.length=0; drops.length=0; decor.length=0; turrets.length=0; portals.length=0; }
  // Ensure maps always repopulate mobs even if no spawn calls happened in gen() due to future edits
  function ensureBaselineSpawns(){
    const countByType = {};
    for(const e of ents){ if(!e.alive) continue; countByType[e.type] = (countByType[e.type]|0) + 1; }
    const need=(type,target)=>{ const have=countByType[type]|0; const missing=Math.max(0,target-have); for(let i=0;i<missing;i++){ let tries=0; while(tries++<800){ const x=(Math.random()*MAP_W)|0,y=(Math.random()*MAP_H)|0; const tt=tiles[y*MAP_W+x]; if(tt===0){ const wx=x*TILE+TILE/2, wy=y*TILE+TILE/2; if(!isInTown(wx,wy)){ spawnMob(type,wx,wy); break; } } } } };
    if(mapName==='plains'){
      // stronger buffers on plains to keep mobs away from canyon and town
      const oldIsInTown = isInTown;
      const guard = (wx,wy)=> oldIsInTown(wx,wy) || (dist(wx,wy,startPos.x,startPos.y)>TILE*26 && (!plainsTownCenter || dist(wx,wy,plainsTownCenter.x,plainsTownCenter.y)>TILE*20));
      const oldSpawn = spawnMob;
      const needGuarded=(type,target)=>{ const have=countByType[type]|0; const missing=Math.max(0,target-have); for(let i=0;i<missing;i++){ let tries=0; while(tries++<1200){ const x=(Math.random()*MAP_W)|0,y=(Math.random()*MAP_H)|0; const tt=tiles[y*MAP_W+x]; if(tt===0){ const wx=x*TILE+TILE/2, wy=y*TILE+TILE/2; if(guard(wx,wy)){ oldSpawn(type,wx,wy); break; } } } } };
      needGuarded('jelly',16); needGuarded('choropy',12);
    }
    else if(mapName==='zant'){ need('woopie',26); }
    else if(mapName==='junon'){ need('moldy',40); need('moldy_elite',12); need('rockgolem',6); }
    else if(mapName==='elverloon'){ need('woopie',34); need('moldy_elite',12); need('rockgolem',6); }
     else if(mapName==='luxem'){ need('choropy',28); }
    else if(mapName==='canyon'){ need('rockgolem',16); need('gorge_beetle',24); }
    else if(mapName==='luna'){ need('luna_wolf',26); need('luna_spirit',16); }
    else if(mapName==='eldeon'){ need('spirit_archer',22); need('thornling',26); need('ancient_treant',1); }
  }

  // Boat travel removed

  function drawBoatNPC(obj){
    const s=worldToScreen(obj.x,obj.y);
    ctx.fillStyle='#3a2c12'; ctx.fillRect(s.x-26, s.y-6, 52, 12);
    ctx.fillStyle='#2b4a6a'; ctx.fillRect(s.x-34, s.y+6, 68, 10);
    ctx.fillStyle='#734c2a'; ctx.beginPath(); ctx.moveTo(s.x-20, s.y+6); ctx.lineTo(s.x+20, s.y+6); ctx.lineTo(s.x+12, s.y+20); ctx.lineTo(s.x-12, s.y+20); ctx.closePath(); ctx.fill();
    ctx.fillStyle='rgba(0,0,0,.55)'; ctx.fillRect(s.x-20, s.y-42, 40, 16);
    ctx.fillStyle='#cfe'; ctx.fillText('‚õµ E', s.x-14, s.y-30);
  }

  // ==== SECTION: NPC SPRITES (enhanced shading) ====
  const NPC_SPRITES = {
    sign: { base:'#3a4b5f', glyph:'‚ÑπÔ∏è' },
    merchant: { base:'#3a5f3a', glyph:'üõí' },
    trainer: { base:'#5b3a5f', glyph:'‚òÖ' },
    storage: { base:'#3a3f5f', glyph:'üß≥' },
    cartmaster: { base:'#5f4a2a', glyph:'üõû' },
    cart: { base:'#445', glyph:'' },
    harbor: { base:'#2b4a6a', glyph:'‚õµ' },
    ferryJ: { base:'#2b4a6a', glyph:'‚õµ' },
    portal: { base:'#3a4b7a', glyph:'üåÄ' }
  };
  function drawNPCSprite(n){
    const bob = Math.sin(performance.now()/600 + (n.x+n.y)*0.02) * 1.2;
    const s=worldToScreen(n.x,n.y + bob);
    if(n.npc==='cart') { drawCart(n); return; }
    const def = NPC_SPRITES[n.npc] || {base:'#3a4b5f', glyph:'?'};
    // soft shadow
    ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.beginPath(); ctx.ellipse(s.x, s.y+14, 16, 8, 0, 0, Math.PI*2); ctx.fill();
    // simplified humanoid sprite (distinct from player by proportions and palette)
    ctx.save(); ctx.translate(s.x, s.y);
    const outfit = def.base;
    const skin = '#e6d2b5';
    const gBody = ctx.createLinearGradient(-9, -22, 9, 12); gBody.addColorStop(0, outfit); gBody.addColorStop(1, '#1b2a38');
    ctx.fillStyle = gBody; ctx.beginPath(); ctx.roundRect(-9, -12, 18, 24, 4); ctx.fill();
    ctx.fillStyle = '#223'; ctx.fillRect(-9, 8, 7, 8); ctx.fillRect(2, 8, 7, 8);
    // head
    ctx.fillStyle = skin; ctx.beginPath(); ctx.arc(0, -18, 7, 0, Math.PI*2); ctx.fill();
    // chest glyph/icon for role
    ctx.fillStyle = '#fff'; ctx.font='12px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; if(def.glyph) ctx.fillText(def.glyph, 0, -2);
    ctx.restore();
    // nameplate + interaction hint
    ctx.fillStyle='rgba(255,255,255,0.9)'; ctx.font='12px system-ui';
    const label = n.npc==='merchant'? 'Merchant' : n.npc==='storage'? 'Storage' : n.npc==='cartmaster'? 'Cart Master' : n.npc==='trainer'? 'Trainer' : n.npc==='sign'? 'Quest' : (n.npc==='harbor'||n.npc==='ferryJ')? 'Travel Boat' : n.npc==='portal'? 'Portal' : '';
    if(label){ ctx.save(); ctx.textAlign='center'; ctx.textBaseline='alphabetic'; ctx.strokeStyle='rgba(0,0,0,0.55)'; ctx.lineWidth=4; ctx.strokeText(label, s.x, s.y-30); ctx.fillStyle='#cfe'; ctx.fillText(label, s.x, s.y-30); ctx.restore(); }
    const hint = (n.npc==='harbor'||n.npc==='ferryJ')? '‚õµ E' : (n.npc==='portal'? 'üåÄ E' : 'E');
    ctx.fillText(hint, s.x, s.y-20);
  }
  function drawNPCSprites(){
    const list=[sign, merchant, trainer, storageNPC];
    if(summonedCart) list.push(summonedCart);
    for(const p of portals){ list.push(p); }
    // depth sort by y
    list.sort((a,b)=>a.y-b.y);
    for(const n of list){ drawNPCSprite(n); }
  }

  function genPlains(){
    for(let i=0;i<MAP_W*MAP_H;i++){
      let x=i%MAP_W, y=(i/MAP_W)|0;
      let g = (Math.sin(x*0.33)+Math.cos(y*0.27))*0.5 + Math.random()*0.6;
      tiles[i] = g>0.55?1:0;
    }
    // Small creek far field for variation
    for(let y=20;y<28;y++) for(let x=20;x<28;x++){ if((x-24)**2+(y-24)**2<16) tiles[y*MAP_W+x]=2; }
    decor.length=0;
    for(let y=0;y<MAP_H;y++){ for(let x=0;x<MAP_W;x++){
      if(tiles[y*MAP_W+x]===0 && Math.random()>0.955) decor.push({t: Math.random()>0.55? 'tree':'rock', x:x*TILE+8+Math.random()*(TILE-16), y:y*TILE+8+Math.random()*(TILE-16)});
      if(tiles[y*MAP_W+x]===0 && Math.random()>0.975) decor.push({t:'flower', x:x*TILE+10+Math.random()*(TILE-20), y:y*TILE+10+Math.random()*(TILE-20)});
    }}
    // Canyon-like spawn (north), town hub further to the right with a proper road
    const canyon = { x:startPos.x, y:startPos.y, r:TILE*5.2 };
    // Canyon rim with layered rock walls and vegetation
    for(let k=0;k<26;k++){
      const a = (k/26)*Math.PI*2; const rr = canyon.r + rand(-8,12);
      const rx = canyon.x + Math.cos(a)*(rr+TILE*0.7);
      const ry = canyon.y + Math.sin(a)*(rr+TILE*0.7);
      decor.push({t:'rock', x:rx, y:ry});
    }
    for(let k=0;k<18;k++){
      const a = (k/18)*Math.PI*2; const rr = canyon.r + TILE*1.4 + rand(-10,10);
      const rx = canyon.x + Math.cos(a)*rr;
      const ry = canyon.y + Math.sin(a)*rr;
      if(Math.random()<0.6) decor.push({t:'tree', x:rx, y:ry}); else decor.push({t:'rock', x:rx, y:ry});
    }
    // L-shaped path from canyon exit ‚Üí eastwards ‚Üí down into town
    const pathWidth = 2; // thicker than before
    const spawnTx = Math.floor(canyon.x / TILE);
    const spawnTy = Math.floor(canyon.y / TILE);
    const eastLenTiles = 14; // move hub to the right
    const elbowTx = Math.min(MAP_W-3, spawnTx + eastLenTiles);
    const startTy = spawnTy + 3; // slight south out of canyon
    const townYTile = startTy + 12;
    // horizontal segment (east)
    for(let tx = Math.min(spawnTx, elbowTx); tx <= Math.max(spawnTx, elbowTx); tx++){
      for(let dy = -pathWidth; dy <= pathWidth; dy++){
        const ty = startTy + dy; if(tx>1 && tx<MAP_W-1 && ty>1 && ty<MAP_H-1) tiles[ty*MAP_W+tx] = 1;
      }
    }
    // vertical segment (south)
    for(let ty = Math.min(startTy, townYTile); ty <= Math.max(startTy, townYTile); ty++){
      for(let dx = -pathWidth; dx <= pathWidth; dx++){
        const tx = elbowTx + dx; if(tx>1 && tx<MAP_W-1 && ty>1 && ty<MAP_H-1) tiles[ty*MAP_W+tx] = 1;
      }
    }
    // decorative canyon gate at exit (two pillars framing the road)
    decor.push({t:'gate', x: elbowTx*TILE, y: (startTy-1)*TILE });
    // Town center placed to the right to avoid edge clipping
    const town = { x: elbowTx*TILE, y: (townYTile)*TILE };
    plainsTownCenter = {x: town.x, y: town.y};
    decor.push({t:'bonfire', x:town.x, y:town.y});
    // Plaza stone around bonfire
    decor.push({t:'plaza', x:town.x, y:town.y, r:TILE*6.6});
    // Buildings and stalls behind each NPC around the bonfire
    const placeBld = (cx,cy,wTiles,hTiles,opts)=>{ const e={t:'bld', x:cx, y:cy, w:wTiles*TILE, h:hTiles*TILE}; if(opts){ Object.assign(e,opts);} decor.push(e); };
    const placeStall = (cx,cy,col)=> decor.push({t:'stall', x:cx, y:cy, col});
    const ring = TILE*2.4;
    // NPC arrangement referencing ROSE AP hub (bonfire in center, NPCs around, with buildings behind)
    sign.x = town.x; sign.y = town.y - ring;
    merchant.x = town.x - ring; merchant.y = town.y + TILE*0.6;
    trainer.x = town.x + ring; trainer.y = town.y + TILE*0.6;
    storageNPC.x = town.x; storageNPC.y = town.y + ring;
    // Buildings behind each NPC (placed away from bonfire)
    placeBld(sign.x, sign.y - TILE*2.2, 3, 2, {roof:'#3f7aa6'}); // bluish roof north
    placeBld(merchant.x - TILE*2.8, merchant.y, 4, 3, {roof:'#a84f3c'}); // red roof west
    placeStall(merchant.x - TILE*1.0, merchant.y - TILE*0.6, '#c95a4a');
    placeBld(trainer.x + TILE*2.8, trainer.y, 4, 3, {roof:'#7aa63f'}); // green roof east
    placeStall(trainer.x + TILE*1.0, trainer.y - TILE*0.6, '#4a8ac9');
    placeBld(storageNPC.x, storageNPC.y + TILE*2.4, 4, 3, {roof:'#a68b3f'}); // ochre roof south
    // Place a few standing stone pillars around the canyon for a proper "spawn ring"
    for(let k=0;k<6;k++){
      const a = (k/6)*Math.PI*2; const rr = canyon.r*0.85; const px = canyon.x + Math.cos(a)*rr; const py = canyon.y + Math.sin(a)*rr; decor.push({t:'pillar', x:px, y:py});
    }
    // Safe zones: canyon spawn and town circle ‚Äî prevents Jelly Beans in both
    townZones.length = 0;
    townZones.push({type:'circle', x:canyon.x, y:canyon.y, r:canyon.r});
    townZones.push({type:'circle', x:town.x, y:town.y, r:TILE*7.4});
    el('zone').textContent = MAPS.plains.label;
    // Spawns outside safe zones
    const spawnOut=(t,count)=>{let n=0,tries=0;while(n<count&&tries<2200){tries++;const x=(Math.random()*MAP_W)|0,y=(Math.random()*MAP_H)|0;const tt=tiles[y*MAP_W+x];if(tt===0){ const wx=x*TILE+TILE/2, wy=y*TILE+TILE/2; if(!isInTown(wx,wy) && dist(wx,wy,startPos.x,startPos.y)>TILE*26 && (!plainsTownCenter || dist(wx,wy,plainsTownCenter.x,plainsTownCenter.y)>TILE*20)){ spawnMob(t,wx,wy); n++; }}}};
    const spawnFar=(t,count,minDist)=>{let n=0,tries=0;while(n<count&&tries<2400){tries++;const x=(Math.random()*MAP_W)|0,y=(Math.random()*MAP_H)|0;const tt=tiles[y*MAP_W+x];if(tt===0){ const wx=x*TILE+TILE/2, wy=y*TILE+TILE/2; const md=(minDist||TILE*28); if(!isInTown(wx,wy) && dist(wx,wy,startPos.x,startPos.y)>md && (!plainsTownCenter || dist(wx,wy,plainsTownCenter.x,plainsTownCenter.y)>TILE*22)){ spawnMob(t,wx,wy); n++; }}}};
    // Jelly Beans only outside town/canyon
    spawnOut('jelly',22);
    // Choropy ring further out
    spawnFar('choropy',18, TILE*28);
    // Portal on the west road, still reachable but not crowding the plaza
    portals.length = 0;
    portals.push({kind:'npc', npc:'portal', x: town.x - TILE*12, y: town.y, r:22, dest:'luxem', tag:'grove'});
    // If story quest is at travel step to Luxem, mark it complete on arrival there (handled on map change)
  }
  function genJunon(){
    for(let i=0;i<MAP_W*MAP_H;i++) tiles[i]=0;
    const cx=18, cy=22, cw=36, ch=26;
    for(let y=cy; y<cy+ch; y++) for(let x=cx; x<cx+cw; x++) tiles[y*MAP_W+x] = 1; // dirt pad
    for(let y=cy-2; y<cy; y++) for(let x=cx-2; x<cx+cw+2; x++) tiles[y*MAP_W+x]=2;
    for(let y=cy+ch; y<cy+ch+2; y++) for(let x=cx-2; x<cx+cw+2; x++) tiles[y*MAP_W+x]=2;
    for(let y=cy-2; y<cy+ch+2; y++) for(let x=cx-2; x<cx; x++) tiles[y*MAP_W+x]=2;
    for(let y=cy-2; y<cy+ch+2; y++) for(let x=cx+cw; x<cx+cw+2; x++) tiles[y*MAP_W+x]=2;
    // Bridge from docks across the eastern canal into the castle
    const by = cy + Math.floor(ch*0.5);
    for(let x=cx+cw-1; x<cx+cw+2; x++){
      for(let y=by-1; y<=by+1; y++) tiles[y*MAP_W+x] = 1;
    }
    // Optional south bridge
    const bsy = cy+ch; const bsx = cx + Math.floor(cw*0.35);
    for(let y=bsy; y<bsy+2; y++){
      for(let x=bsx-1; x<=bsx+1; x++) tiles[y*MAP_W+x]=1;
    }
    const bld = (bx,by,bw,bh)=> decor.push({t:'bld', x:(bx+0.5)*TILE, y:(by+0.5)*TILE, w:bw*TILE, h:bh*TILE});
    bld(cx+2, cy+3, 8, 6); bld(cx+15, cy+3, 8, 6); bld(cx+28, cy+3, 6, 6);
    bld(cx+3, cy+16, 10, 7); bld(cx+19, cy+16, 8, 7); bld(cx+29, cy+16, 8, 7);
    ferryJ.x = (cx+cw+1)*TILE; ferryJ.y = (cy+ch+1)*TILE;
    merchant.x = (cx+Math.floor(cw/2))*TILE; merchant.y = (cy+12)*TILE;
    trainer.x = (cx+Math.floor(cw/2)-2)*TILE; trainer.y = (cy+10)*TILE;
    storageNPC.x = (cx+Math.floor(cw/2)+3)*TILE; storageNPC.y = (cy+10)*TILE;
    sign.x = (cx+Math.floor(cw/2))*TILE; sign.y = (cy+9)*TILE;
    // Define the inner city rectangle as safe town (slightly expanded)
    townZones.length = 0;
    townZones.push({type:'rect', x:(cx-1)*TILE, y:(cy-1)*TILE, w:(cw+2)*TILE, h:(ch+2)*TILE});
    el('zone').textContent = MAPS.junon.label;
    // Junon spawns (Patch 7): tougher mobs
    const spawnOut=(t,count)=>{let n=0,tries=0;while(n<count&&tries<1200){tries++;const x=(Math.random()*MAP_W)|0,y=(Math.random()*MAP_H)|0;const tt=tiles[y*MAP_W+x]; if(tt===0||tt===1){ const wx=x*TILE+TILE/2, wy=y*TILE+TILE/2; if(!isInTown(wx,wy)){ spawnMob(t,wx,wy); n++; }}}};
    spawnOut('moldy',44); spawnOut('moldy_elite',14); spawnOut('rockgolem',6);
    // Simplify: Junon has a single portal ‚Üí Luxem
    portals.length = 0;
    portals.push({kind:'npc', npc:'portal', x:(cx-2)*TILE, y:(cy+Math.floor(ch/2))*TILE, r:22, dest:'luxem', tag:'grove'});
  }

  // Zant ‚Äî desert village with sandy dunes
  function genZant(){
    for(let i=0;i<MAP_W*MAP_H;i++) tiles[i]=1; // sand base
    const cx=20, cy=16, cw=26, ch=18;
    for(let y=cy; y<cy+ch; y++) for(let x=cx; x<cx+cw; x++) tiles[y*MAP_W+x] = 1;
    // scatter rocks and sparse shrubs + new cacti/bones
    decor.length=0;
    for(let i=0;i<90;i++) decor.push({t:'rock', x: rand(TILE*3, TILE*(MAP_W-3)), y: rand(TILE*3, TILE*(MAP_H-3))});
    for(let i=0;i<24;i++) decor.push({t:'cactus', x: rand(TILE*3, TILE*(MAP_W-3)), y: rand(TILE*3, TILE*(MAP_H-3))});
    for(let i=0;i<14;i++) decor.push({t:'bones', x: rand(TILE*3, TILE*(MAP_W-3)), y: rand(TILE*3, TILE*(MAP_H-3))});
    // NPCs (plaza)
    sign.x=(cx+Math.floor(cw/2))*TILE; sign.y=(cy+2)*TILE;
    merchant.x=(cx+Math.floor(cw/2)-3)*TILE; merchant.y=(cy+8)*TILE;
    trainer.x=(cx+Math.floor(cw/2)+3)*TILE; trainer.y=(cy+8)*TILE;
    storageNPC.x=(cx+Math.floor(cw/2))*TILE; storageNPC.y=(cy+10)*TILE;
    // town safe zone ‚Äî rectangular plaza around NPCs
    townZones.length=0; townZones.push({type:'rect', x:(cx-2)*TILE, y:(cy-3)*TILE, w:(cw+4)*TILE, h:(ch+6)*TILE});
    el('zone').textContent = MAPS.zant.label;
    // spawns outside town
    const spawnOut=(t,count)=>{let n=0,tries=0;while(n<count&&tries<1600){tries++;const x=(Math.random()*MAP_W)|0,y=(Math.random()*MAP_H)|0;const tt=tiles[y*MAP_W+x]; if(tt===0||tt===1){ const wx=x*TILE+TILE/2, wy=y*TILE+TILE/2; if(!isInTown(wx,wy)){ spawnMob(t,wx,wy); n++; }}}};
    // Ensure visibility: spawn a cluster near town edge
    const ringSpawn=(t,count,rad)=>{let n=0,ang=0; while(n<count){ const wx=(cx+cw+3)*TILE + Math.cos(ang)*rad; const wy=(cy+Math.floor(ch/2))*TILE + Math.sin(ang)*rad; if(!isInTown(wx,wy)) { spawnMob(t,wx,wy); n++; } ang+=Math.PI*2/count; }};
    spawnOut('woopie',32);
    ringSpawn('woopie',6, TILE*8);
    // Zant ‚Üí El Verloon only (progression forward)
    portals.length=0;
    portals.push({kind:'npc', npc:'portal', x:(cx+Math.floor(cw/2))*TILE, y:(cy-2)*TILE, r:22, dest:'elverloon', tag:'oasis'});
  }

  // El Verloon Desert ‚Äî sandy open area with tougher mobs
  function genElVerloon(){
    for(let i=0;i<MAP_W*MAP_H;i++) tiles[i]=1; // sand as dirt
    // Create oases (water patches)
    for(let i=0;i<4;i++){
      const ox=(Math.random()*MAP_W)|0, oy=(Math.random()*MAP_H)|0;
      for(let y=oy-3;y<=oy+3;y++) for(let x=ox-5;x<=ox+5;x++) if(x>=0&&y>=0&&x<MAP_W&&y<MAP_H) tiles[y*MAP_W+x]=2;
    }
    decor.length=0; for(let i=0;i<90;i++) decor.push({t:'rock', x: rand(TILE*3,TILE*(MAP_W-3)), y: rand(TILE*3,TILE*(MAP_H-3))});
    // NPC cluster near an oasis
    merchant.x = TILE*54; merchant.y = TILE*24; trainer.x = TILE*56; trainer.y = TILE*24; storageNPC.x = TILE*55; storageNPC.y = TILE*26; sign.x = TILE*54; sign.y = TILE*22;
    townZones.length=0; townZones.push({type:'circle', x:TILE*54, y:TILE*24, r:TILE*6});
    el('zone').textContent = MAPS.elverloon.label;
    const spawnOut=(t,count)=>{let n=0,tries=0;while(n<count&&tries<1600){tries++;const x=(Math.random()*MAP_W)|0,y=(Math.random()*MAP_H)|0;const tt=tiles[y*MAP_W+x];if(tt===0||tt===1){ const wx=x*TILE+TILE/2, wy=y*TILE+TILE/2; if(!isInTown(wx,wy)){ spawnMob(t,wx,wy); n++; }}}};
    spawnOut('woopie',40); spawnOut('moldy_elite',14); spawnOut('rockgolem',8);
    portals.length=0; 
    // Simplify: El Verloon ‚Üí Junon only
    portals.push({kind:'npc', npc:'portal', x:TILE*18, y:TILE*48, r:22, dest:'junon', tag:'gate'});
  }

// Luxem Forest ‚Äî dense trees, mid mobs
function genLuxem(){
  for(let i=0;i<MAP_W*MAP_H;i++) tiles[i]=0;
  // Dense forest patches
  decor.length=0;
  for(let y=0;y<MAP_H;y++){
    for(let x=0;x<MAP_W;x++){
      if(Math.random()>0.94) decor.push({t:'tree', x:x*TILE+8+Math.random()*(TILE-16), y:y*TILE+8+Math.random()*(TILE-16)});
      if(Math.random()>0.985) decor.push({t:'flower', x:x*TILE+10+Math.random()*(TILE-20), y:y*TILE+10+Math.random()*(TILE-20)});
    }
  }
  // Creek
  for(let y=10;y<MAP_H-10;y++) for(let x=24;x<27;x++) tiles[y*MAP_W+x]=2;
  // NPC cluster at grove
  const gx = 28, gy = 22; sign.x = gx*TILE; sign.y = (gy-2)*TILE; merchant.x = (gx+2)*TILE; merchant.y = gy*TILE; trainer.x = (gx-2)*TILE; trainer.y = gy*TILE; storageNPC.x = gx*TILE; storageNPC.y = (gy+2)*TILE;
  townZones.length=0; townZones.push({type:'circle', x:gx*TILE, y:gy*TILE, r:TILE*6});
  el('zone').textContent = MAPS.luxem.label;
  // Spawns: choropy only (no Woopies in Luxem)
  const spawnOut=(t,count)=>{let n=0,tries=0;while(n<count&&tries<1400){tries++;const x=(Math.random()*MAP_W)|0,y=(Math.random()*MAP_H)|0;const tt=tiles[y*MAP_W+x];if(tt===0){ const wx=x*TILE+TILE/2, wy=y*TILE+TILE/2; if(!isInTown(wx,wy)){ spawnMob(t,wx,wy); n++; }}}};
  spawnOut('choropy',30);
    portals.length=0;
    // Luxem exits forward only ‚Üí Zant (no direct Junon)
    portals.push({kind:'npc', npc:'portal', x:(gx-6)*TILE, y:gy*TILE, r:22, dest:'zant', tag:'plaza'});
}

  // Canyon (Gorge) ‚Äî rocky ravines and plateaus, lv 20‚Äì30
  function genCanyon(){
    for(let i=0;i<MAP_W*MAP_H;i++) tiles[i] = (Math.random()<0.15? 1: 0);
    // carve canyon lines (dirt paths as ridges)
    for(let y=8;y<MAP_H-8;y+=6){ for(let x=2;x<MAP_W-2;x++){ tiles[y*MAP_W+x]=1; } }
    // town-like camp center
    const cx=30, cy=24; merchant.x = (cx)*TILE; merchant.y = (cy)*TILE; trainer.x = (cx-3)*TILE; trainer.y = (cy)*TILE; storageNPC.x=(cx+3)*TILE; storageNPC.y=(cy)*TILE; sign.x=cx*TILE; sign.y=(cy-2)*TILE;
    townZones.length=0; townZones.push({type:'rect', x:(cx-2)*TILE, y:(cy-2)*TILE, w:TILE*6, h:TILE*6});
    el('zone').textContent = MAPS.canyon.label;
    // spawns: golems and beetles
    const spawnOut=(t,count)=>{let n=0,tries=0;while(n<count&&tries<1800){tries++;const x=(Math.random()*MAP_W)|0,y=(Math.random()*MAP_H)|0;const tt=tiles[y*MAP_W+x]; if(tt===0||tt===1){ const wx=x*TILE+TILE/2, wy=y*TILE+TILE/2; if(!isInTown(wx,wy)){ spawnMob(t,wx,wy); n++; }}}};
    spawnOut('rockgolem',12); spawnOut('gorge_beetle',28);
    portals.length=0; portals.push({kind:'npc', npc:'portal', x:(cx+8)*TILE, y:(cy+10)*TILE, r:22, dest:'junon', tag:'gate'});
  }

  // Luna ‚Äî icy plateaus and moonlit woods, lv 30‚Äì40
  function genLuna(){
    for(let i=0;i<MAP_W*MAP_H;i++) tiles[i] = 0;
    // add ice lakes
    for(let y=12;y<22;y++) for(let x=20;x<32;x++){ tiles[y*MAP_W+x]=2; }
    const cx=22, cy=18; merchant.x=(cx+2)*TILE; merchant.y=(cy+2)*TILE; trainer.x=(cx-2)*TILE; trainer.y=(cy+2)*TILE; storageNPC.x=cx*TILE; storageNPC.y=(cy+4)*TILE; sign.x=cx*TILE; sign.y=(cy)*TILE;
    townZones.length=0; townZones.push({type:'rect', x:(cx-3)*TILE, y:(cy-3)*TILE, w:TILE*10, h:TILE*8});
    el('zone').textContent = MAPS.luna.label;
    const spawnOut=(t,count)=>{let n=0,tries=0;while(n<count&&tries<1800){tries++;const x=(Math.random()*MAP_W)|0,y=(Math.random()*MAP_H)|0;const tt=tiles[y*MAP_W+x]; if(tt===0){ const wx=x*TILE+TILE/2, wy=y*TILE+TILE/2; if(!isInTown(wx,wy)){ spawnMob(t,wx,wy); n++; }}}};
    spawnOut('luna_wolf',24); spawnOut('luna_spirit',16);
    portals.length=0; portals.push({kind:'npc', npc:'portal', x:(cx+10)*TILE, y:(cy+4)*TILE, r:22, dest:'eldeon', tag:'grove'});
  }

  // Eldeon Glade ‚Äî bioluminescent forest, lv 40‚Äì50
  function genEldeon(){
    for(let i=0;i<MAP_W*MAP_H;i++) tiles[i] = 0;
    // water veins
    for(let y=8;y<MAP_H-8;y++) for(let x=14;x<17;x++){ tiles[y*MAP_W+x]=2; }
    for(let y=12;y<MAP_H-12;y++) for(let x=40;x<42;x++){ tiles[y*MAP_W+x]=2; }
    // glowing decor clusters
    decor.length=0; for(let i=0;i<160;i++){ decor.push({t:'flower', x:rand(TILE*3,TILE*(MAP_W-3)), y:rand(TILE*3,TILE*(MAP_H-3))}); }
    const cx=24, cy=20; merchant.x=(cx+2)*TILE; merchant.y=(cy+2)*TILE; trainer.x=(cx-2)*TILE; trainer.y=(cy+2)*TILE; storageNPC.x=cx*TILE; storageNPC.y=(cy+4)*TILE; sign.x=cx*TILE; sign.y=(cy)*TILE;
    townZones.length=0; townZones.push({type:'circle', x:cx*TILE, y:cy*TILE, r:TILE*6});
    el('zone').textContent = MAPS.eldeon.label;
    const spawnOut=(t,count)=>{let n=0,tries=0;while(n<count&&tries<2200){tries++;const x=(Math.random()*MAP_W)|0,y=(Math.random()*MAP_H)|0;const tt=tiles[y*MAP_W+x]; if(tt===0){ const wx=x*TILE+TILE/2, wy=y*TILE+TILE/2; if(!isInTown(wx,wy)){ spawnMob(t,wx,wy); n++; }}}};
    spawnOut('spirit_archer',22); spawnOut('thornling',26);
    // one treant mini-boss
    let tries=0; while(tries++<200){ const x=rand(TILE*8,TILE*(MAP_W-8)), y=rand(TILE*8,TILE*(MAP_H-8)); if(!isInTown(x,y)){ spawnMob('ancient_treant',x,y); break; } }
    // forward portal ‚Üí stub next
    portals.length=0; portals.push({kind:'npc', npc:'portal', x:(cx+14)*TILE, y:(cy-6)*TILE, r:22, dest:'canyon', tag:'rim'});
  }

  // Cart summon
  let summonedCart=null;
  function toggleSummonCart(){
    if(!player.flags.cartUnlocked){ notify('You need a Cart License.'); return; }
    if(player.mounted){ player.mounted=false; recalcStats(); mountChip.style.display='none'; notify('Dismounted'); return; }
    if(summonedCart){ if(nearest(summonedCart)<TILE*1.8){ mountCart(); return; } }
    const a=player.dir; const cx=player.x+Math.cos(a)*TILE*1.4, cy=player.y+Math.sin(a)*TILE*1.4; summonedCart={kind:'npc', npc:'cart', x:cx, y:cy, r:24, summoned:true}; notify('Cart summoned (press E near it)');
  }

  // Jobs UI
  function openJobs(){ jobList.innerHTML='';
    // Smith refine UI at top
    const refineDiv=document.createElement('div'); refineDiv.className='item';
    refineDiv.innerHTML=`<b>Refine & Socket</b> <span class="pill">Costs Gold</span><div style="font-size:12px; opacity:.85; margin-top:4px">Refine to boost stats and glow. Socket a gem into a shield to imbue bonuses and glow.</div>`;
    const refineActions=document.createElement('div'); const refineBtn=document.createElement('button'); refineBtn.textContent='Refine‚Ä¶';
    refineBtn.onclick=()=>{ openRefineWindow(); };
    jobList.appendChild(refineDiv); jobList.appendChild(refineActions); refineActions.appendChild(refineBtn);
    const jobs=['Soldier','Hawker','Dealer','Muse'];
    jobs.forEach(j=>{ const item=document.createElement('div'); item.className='item';
      const desc = j==='Soldier'? 'Frontline melee. Swords & heavy strikes.' : j==='Hawker'? 'Agile archer/raider. Bows & katars.' : j==='Dealer'? 'Crafty tinkerer. Bombs & turrets.' : 'Magic user. Bolts & heals.';
      item.innerHTML=`<b>${j}</b> <span class="pill">${desc}</span>`; const actions=document.createElement('div'); const btn=document.createElement('button'); btn.textContent = player.level>=10? ('Become '+j) : 'Reach Lv 10'; btn.disabled = player.level<10; btn.onclick=()=>{ changeJob(j); jobWin.style.display='none'; }; actions.appendChild(btn); jobList.appendChild(item); jobList.appendChild(actions); });
    jobWin.style.display='block'; }

  function changeJob(j){ player.job=j; jobEl.textContent=j; notify('Job changed to '+j); setSkillsForJob(j); if(j==='Soldier') addToInv('wood_sword',1); if(j==='Hawker') addToInv('wood_bow',1); if(j==='Dealer') addToInv('wood_katar',1); if(j==='Muse') addToInv('wood_wand',1); save(); }

  function setSkillsForJob(job){
    // Keep slot 1 as weapon AOE; add new job skills at Lv 12‚Äì14 and 22‚Äì24
    const wepType = getEquippedWeaponType();
    const aoeForWeapon = ()=>{
      if(wepType==='sword') return {id:'whirlwind', name:'Whirlwind', icon:'üåÄ', cd:10, mp:14, use:()=>superWhirlwind(), unlockedBelow10:true, desc:'Spin attack around you.', req:{wep:'sword'}};
      if(wepType==='staff') return {id:'windstorm', name:'Windstorm', icon:'üå™Ô∏è', cd:12, mp:16, use:()=>superWindstorm(), unlockedBelow10:true, desc:'Magical wind pulses.', req:{wep:'staff'}};
      if(wepType==='wand') return {id:'arcane_nova', name:'Arcane Nova', icon:'‚ú®', cd:10, mp:14, use:()=>superWandNova(), unlockedBelow10:true, desc:'Release a nova of mana.', req:{wep:'wand'}};
      if(wepType==='bow') return {id:'arrow_volley', name:'Arrow Volley', icon:'üéØ', cd:10, mp:12, use:()=>superBowVolley(), unlockedBelow10:true, desc:'Volley of arrows all directions.', req:{wep:'bow'}};
      if(wepType==='gun') return {id:'bullet_storm', name:'Bullet Storm', icon:'üí•', cd:12, mp:14, use:()=>superGunShockwave(), unlockedBelow10:true, desc:'Spray bullets in every direction.', req:{wep:'gun'}};
      if(wepType==='katar') return {id:'blade_flurry', name:'Blade Flurry', icon:'ü•∑', cd:10, mp:12, use:()=>superKatarFlurry(), unlockedBelow10:true, desc:'Rapid circular slashes.', req:{wep:'katar'}};
      return {id:'whirlwind', name:'Whirlwind', icon:'üåÄ', cd:10, mp:12, use:()=>superWhirlwind(), unlockedBelow10:true, desc:'Spin attack around you.', req:{wep:'sword'}};
    };
    player.skills[0] = aoeForWeapon(); sicons[0].textContent = player.skills[0].icon;
    // New slot 2 skill per job (Lv 12‚Äì14)
    let slot2 = null;
    if(job==='Soldier') slot2 = {id:'shield_dash', name:'Shield Dash', icon:'üõ°Ô∏è', cd:8, mp:10, use:()=>{ dash(140); fx.push({t:0.22, kind:'burst', x:player.x, y:player.y, r:60}); for(const m of ents){ if(!m.alive) continue; if(dist(player.x,player.y,m.x,m.y)<56){ const out=calcDamage(player.atk*0.9,'physical'); m.hp-=out.dmg; showDamage(m.x,m.y,out.dmg,out.crit,'physical'); m.hurt=0.18; if(m.hp<=0){ m.alive=false; onMobKilled(m);} } } }, desc:'Dash forward, damaging nearby foes.', req:{wep:'sword'}};
    else if(job==='Hawker') slot2 = {id:'poison_shot', name:'Poison Shot', icon:'‚ò†Ô∏è', cd:6, mp:12, use:()=>{ const ang=getAimDir(); shoot(player.x,player.y,ang, player.atk*0.7, player.projSpeed+40,'player','arrow'); player.buffs.push({poisonTag:true,t:6}); }, desc:'Ranged shot that poisons. Synergy: Flurry +20% vs Poisoned'};
    else if(job==='Dealer') slot2 = {id:'sticky_bomb', name:'Sticky Bomb', icon:'üß™', cd:8, mp:12, use:()=>{ grenade(); }, desc:'Lob a sticky bomb that explodes.'};
    else if(job==='Muse') slot2 = {id:'frost_root', name:'Frost Root', icon:'‚ùÑÔ∏è', cd:10, mp:14, use:()=>{ const r=120; for(const m of ents){ if(!m.alive) continue; if(dist(player.x,player.y,m.x,m.y)<r){ m.speed = Math.max(20, (m.speed||90)*0.35); m.hurt=0.2; } } fx.push({t:0.22, kind:'wind', x:player.x, y:player.y, r:120, a:0}); }, desc:'Root nearby enemies briefly.'};
    player.skills[1] = (player.level>=12? slot2 : null); sicons[1].textContent = player.skills[1]? player.skills[1].icon : '‚Äî';
    // New slot 3 skill per job (Lv 22‚Äì24)
    let slot3 = null;
    if(job==='Soldier') slot3 = {id:'iron_skin', name:'Iron Skin', icon:'ü™®', cd:18, mp:12, use:()=>{ player.buffs.push({t:12, def:10, icon:'ü™®', desc:'Defense Up'}); notify('Armor up!'); }, desc:'Temporary armor buff.'};
    else if(job==='Hawker') slot3 = {id:'evasion_stance', name:'Evasion Stance', icon:'üåÄ', cd:18, mp:10, use:()=>{ player.buffs.push({t:10, acc:-0.08, icon:'üåÄ', desc:'Evasion Up'}); notify('Evasion up!'); }, desc:'Briefly harder to hit.'};
    else if(job==='Dealer') slot3 = {id:'slow_field', name:'Slow Field', icon:'üß≤', cd:16, mp:14, use:()=>{ const cx=player.x, cy=player.y; fx.push({t:0.25, kind:'shock', x:cx, y:cy, r:140}); for(const m of ents){ if(!m.alive) continue; if(dist(cx,cy,m.x,m.y)<140){ m.speed = Math.max(30, (m.speed||90)*0.5); } } }, desc:'Area slow trap.'};
    else if(job==='Muse') slot3 = {id:'party_regen', name:'Party Regen', icon:'‚ûï', cd:16, mp:16, use:()=>{ player.buffs.push({t:10, regen:4, icon:'‚ûï', desc:'Regeneration'}); }, desc:'Regenerate over time.'};
    player.skills[2] = (player.level>=22? slot3 : null); sicons[2].textContent = player.skills[2]? player.skills[2].icon : '‚Äî';
    // Keep slot 4 empty for now
    player.skills[3] = null; sicons[3].textContent='‚Äî';
  }

  // PATCH 1: weapon-aware helpers and primary attack
  function getEquippedWeaponType(){
    const wid = player.eq.weapon;
    if(!wid) return 'fist';
    const it = ITEM_DB[wid];
    return (it && it.wep) ? (it.wep==='sword1h'||it.wep==='sword2h'?'sword':it.wep) : 'fist';
  }

  // Minimal sound engine (Sfx) ‚Äî lightweight ROSE-like cues
  const Sfx=(function(){
    const Ctx = (window.AudioContext||window.webkitAudioContext);
    const ctx = Ctx? new Ctx() : null;
    function playHit(freq=340, dur=0.06){ if(!ctx) return; const t=ctx.currentTime; const o=ctx.createOscillator(); const g=ctx.createGain(); const filt=ctx.createBiquadFilter(); filt.type='lowpass'; filt.frequency.value=1200; o.type='triangle'; o.frequency.value=freq; g.gain.setValueAtTime(0.08,t); g.gain.exponentialRampToValueAtTime(0.001, t+dur); o.connect(filt).connect(g).connect(ctx.destination); o.start(t); o.stop(t+dur); }
    function playBow(){ if(!ctx) return; const t=ctx.currentTime; const n=ctx.createNoise? ctx.createNoise() : null; const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sawtooth'; o.frequency.value=120; g.gain.setValueAtTime(0.04,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.08); o.connect(g).connect(ctx.destination); o.start(t); o.stop(t+0.08); }
    function playCast(){ if(!ctx) return; const t=ctx.currentTime; const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='sine'; o.frequency.setValueAtTime(900,t); o.frequency.exponentialRampToValueAtTime(400,t+0.14); g.gain.setValueAtTime(0.06,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.14); o.connect(g).connect(ctx.destination); o.start(t); o.stop(t+0.14); }
    function playGun(){ if(!ctx) return; const t=ctx.currentTime; const o=ctx.createOscillator(); const g=ctx.createGain(); const f=ctx.createBiquadFilter(); f.type='highpass'; f.frequency.value=500; o.type='square'; o.frequency.value=220; g.gain.setValueAtTime(0.07,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.06); o.connect(f).connect(g).connect(ctx.destination); o.start(t); o.stop(t+0.06); }
    function playGold(){ if(!ctx) return; const t=ctx.currentTime; const o=ctx.createOscillator(); const g=ctx.createGain(); o.type='triangle'; o.frequency.value=880; g.gain.setValueAtTime(0.05,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.12); o.connect(g).connect(ctx.destination); o.start(t); o.stop(t+0.12); }
    function play(name){
      if(name==='slash') playHit(300,0.07);
      else if(name==='bow') playBow();
      else if(name==='cast') playCast();
      else if(name==='gun') playGun();
      else if(name==='gold') playGold();
      else if(name==='hit') playHit(360,0.05);
    }
    return { play };
  })();

  // Aiming decoupled from facing. Player sprite does not rotate with the mouse.
  function getAimDir(){
    return Math.atan2((mouse.y+camera.y)-player.y, (mouse.x+camera.x)-player.x);
  }

  function shoot(sx, sy, angle, dmg, speed, owner='player', kind='arrow'){
    const vx = Math.cos(angle) * speed;
    const vy = Math.sin(angle) * speed;
    if(owner==='player'){
      const out = calcDamage(dmg, kind==='magic'? 'magic':'physical');
      projs.push({ x:sx, y:sy, vx, vy, dmg: out.dmg, crit: out.crit, ttl: 1.6, owner, kind, trailT: 0, accRoll: true });
    } else {
      projs.push({ x:sx, y:sy, vx, vy, dmg, ttl: 1.6, owner, kind, trailT: 0 });
    }
  }

  function drawProjectile(p){
    const s = worldToScreen(p.x,p.y);
    if(p.kind==='rocket'){
      // rocket body
      ctx.save(); ctx.translate(s.x,s.y); const ang=Math.atan2(p.vy,p.vx); ctx.rotate(ang);
      ctx.fillStyle='#f5a76e'; ctx.fillRect(-8,-3,16,6); // body
      ctx.fillStyle='#ffe29a'; ctx.beginPath(); ctx.moveTo(-10,-4); ctx.lineTo(-16,0); ctx.lineTo(-10,4); ctx.closePath(); ctx.fill(); // flame
      ctx.restore();
      // thick smoke trail
      if(p.trailT<=0){ p.trailT = 0.04; fx.push({t:0.25, kind:'trail', x:p.x - p.vx*0.06, y:p.y - p.vy*0.06}); } else { p.trailT -= 0.016; }
      } else {
      // Magic vs physical vs fire visuals
      if(p.kind==='fire'){
        const ang=Math.atan2(p.vy,p.vx); ctx.save(); ctx.translate(s.x,s.y); ctx.rotate(ang);
        ctx.fillStyle='#ffa24a'; ctx.beginPath(); ctx.ellipse(0,0,8,5,0,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#fff0'; ctx.restore();
        if(p.trailT<=0){ p.trailT = 0.04; fx.push({t:0.18, kind:'flame', x:p.x - p.vx*0.06, y:p.y - p.vy*0.06}); } else { p.trailT -= 0.016; }
      } else {
        ctx.fillStyle = p.owner==='player' ? (p.kind==='magic' ? '#d8b6ff' : (p.kind==='bullet'? '#ffd24a' : '#cfe')) : '#f88';
        ctx.beginPath(); ctx.arc(s.x, s.y, 5, 0, Math.PI*2); ctx.fill();
        if(p.trailT<=0){ p.trailT = 0.06; fx.push({t:0.06, kind:'trail', x:p.x - p.vx*0.04, y:p.y - p.vy*0.04}); } else { p.trailT -= 0.016; }
      }
    }
  }

  function primaryAttack(){
    const wep = getEquippedWeaponType();
    player.atkTimer = player.atkCd;
    if(wep === 'sword'){ arcStrike(70, 1.05, 1, 10); vibrate(8); Sfx.play('slash'); return; }
    if(wep === 'katar'){ arcStrike(56, 0.55, 2, 10); vibrate(6); return; }
    if(wep === 'launcher'){ const ang = getAimDir(); shoot(player.x, player.y, ang, player.atk*1.05+4, 240, 'player', 'rocket'); return; }
    if(wep === 'bow'){ const spread = mouse.down ? (Math.random()*0.02 - 0.01) : 0; const ang = getAimDir() + spread; shoot(player.x, player.y, ang, player.atk*0.95, player.projSpeed+90, 'player', 'arrow'); Sfx.play('bow'); return; }
    if(wep === 'gun'){ const spread = (Math.random()*0.04 - 0.02); const ang = getAimDir() + spread; shoot(player.x, player.y, ang, player.atk*0.9, player.projSpeed+110, 'player', 'bullet'); Sfx.play('gun'); return; }
    if(wep === 'staff'){ shoot(player.x, player.y, getAimDir(), player.atk*1.15+6, player.projSpeed+10, 'player', 'fire'); player.mp = clamp(player.mp-4, 0, player.mpMax); Sfx.play('cast'); return; }
    if(wep === 'wand'){ shoot(player.x, player.y, getAimDir(), player.atk*0.95+8, player.projSpeed+24, 'player', 'magic'); Sfx.play('cast'); return; }
    // fists if no weapon
    if(wep === 'fist'){ arcStrike(38, 0.45, 2); vibrate(4); return; }
    // fallback (should not happen)
    shoot(player.x, player.y, getAimDir(), player.atk*0.6, player.projSpeed, 'player', 'arrow');
  }

  // PATCH 2: XP, drops, onMobKilled
  function grantXP(xp){
    player.xp += xp;
    while(player.xp >= xpFor(player.level)){
      const need = xpFor(player.level);
      player.xp -= need;
      player.level = Math.min(MAX_LEVEL, player.level+1);
      player.baseAtk += 2;
      player.hpMax += 10;
      player.hp = player.hpMax;
      player.statPoints = (player.statPoints|0) + 3;
      recalcStats();
      notify('Level Up! Lv '+player.level);
      if(player.level%5===0){ spawnBuffFairies(); }
    }
    save();
  }
  function dropGold(x, y, min, max){ const g = (min + Math.floor(Math.random()*(max-min+1)))|0; if(g>0) drops.push({x, y, t:0, gold:g}); }

  function dropItemRoll(m){
    const rolls = [];
    if(m.type==='jelly'){
      if(Math.random()<0.30) rolls.push('potion_hp');
      if(Math.random()<0.22) rolls.push('potion_mp');
      if(Math.random()<0.07) rolls.push('wood_sword');
      if(Math.random()<0.05) rolls.push('wood_wand');
      if(Math.random()<0.02) rolls.push('cap_basic');
    }
    if(m.type==='pumpkin'){
      if(Math.random()<0.28) rolls.push('potion_hp');
      if(Math.random()<0.06) rolls.push('wood_bow');
      if(Math.random()<0.06) rolls.push('leather_armor');
      if(Math.random()<0.05) rolls.push('runner_shoes');
      if(Math.random()<0.03) rolls.push('ring_bronze');
    }
    if(m.type==='flanae'){
      if(Math.random()<0.22) rolls.push('potion_mp');
      if(Math.random()<0.07) rolls.push('wood_katar');
      if(Math.random()<0.05) rolls.push('feather_charm');
      if(Math.random()<0.02) rolls.push('cloak_travel');
    }
    if(m.type==='jellyking'){
      if(Math.random()<0.85) rolls.push('potion_hp');
      if(Math.random()<0.85) rolls.push('potion_mp');
      if(Math.random()<0.35) rolls.push('wood_staff');
      if(Math.random()<0.35) rolls.push('wood_wand');
      if(Math.random()<0.30) rolls.push('wood_bow');
      if(Math.random()<0.20) rolls.push('wood_2h_sword');
      if(Math.random()<0.25) rolls.push('wood_sword');
      if(Math.random()<0.30) rolls.push('wood_katar');
      if(Math.random()<0.40) rolls.push('leather_armor');
      if(Math.random()<0.30) rolls.push('feather_charm');
      if(Math.random()<0.40) rolls.push('runner_shoes');
      if(Math.random()<0.20) rolls.push('helmet_iron');
      if(Math.random()<0.18) rolls.push('ring_silver');
      if(Math.random()<0.14) rolls.push('cloak_royal');
      if(Math.random()<0.25) rolls.push('power_candy');
      if(Math.random()<0.20) rolls.push('royal_core');
    }
    if(m.type==='moldy'){
      if(Math.random()<0.22) rolls.push('potion_hp');
      if(Math.random()<0.08) rolls.push('wood_sword');
      if(Math.random()<0.06) rolls.push('wood_katar');
      if(Math.random()<0.02) rolls.push('wood_shield');
      if(Math.random()<0.03) rolls.push('cap_basic');
    }
    if(m.type==='moldy_elite'){
      if(Math.random()<0.25) rolls.push('potion_hp');
      if(Math.random()<0.10) rolls.push('wood_staff');
      if(Math.random()<0.10) rolls.push('wood_bow');
      if(Math.random()<0.06) rolls.push('wood_gun');
      if(Math.random()<0.08) rolls.push('runner_shoes');
      if(Math.random()<0.08) rolls.push('helmet_iron');
    }
    if(m.type==='rockgolem'){
      if(Math.random()<0.35) rolls.push('potion_hp');
      if(Math.random()<0.15) rolls.push('leather_armor');
      if(Math.random()<0.12) rolls.push('royal_core');
      if(Math.random()<0.06) rolls.push('helmet_iron');
      if(Math.random()<0.06) rolls.push('wood_shield');
    }
    if(m.type==='choropy'){
      if(Math.random()<0.28) rolls.push('potion_mp');
      if(Math.random()<0.10) rolls.push('feather_charm');
      if(Math.random()<0.04) rolls.push('butterfly_wings');
      if(Math.random()<0.02) rolls.push('ring_silver');
    }
    if(m.type==='woopie'){
      if(Math.random()<0.30) rolls.push('potion_hp');
      if(Math.random()<0.08) rolls.push('runner_shoes');
      if(Math.random()<0.05) rolls.push('angel_wings');
      if(Math.random()<0.04) rolls.push('ring_bronze');
    }
    if(m.type==='gorge_beetle'){
      if(Math.random()<0.32) rolls.push('potion_hp');
      if(Math.random()<0.10) rolls.push('iron_sword');
      if(Math.random()<0.10) rolls.push('composite_bow');
      if(Math.random()<0.08) rolls.push('helmet_knight');
    }
    if(m.type==='woopie_elite'){
      if(Math.random()<0.80) rolls.push('ring_silver');
      if(Math.random()<0.50) rolls.push('potion_hp');
    }
    if(m.type==='spirit_archer' || m.type==='thornling'){
      if(Math.random()<0.30) rolls.push('potion_mp');
      if(Math.random()<0.10) rolls.push('ring_silver');
    }
    if(m.type==='ancient_treant'){
      rolls.push('cloak_royal');
      if(Math.random()<0.60) rolls.push('s7');
      if(Math.random()<0.40) rolls.push('emerald7');
    }
    if(m.type==='luna_wolf'){
      if(Math.random()<0.36) rolls.push('potion_hp');
      if(Math.random()<0.12) rolls.push('mechanical_wings');
      if(Math.random()<0.10) rolls.push('steel_armor');
    }
    if(m.type==='luna_spirit'){
      if(Math.random()<0.34) rolls.push('potion_mp');
      if(Math.random()<0.12) rolls.push('mystic_wand');
      if(Math.random()<0.10) rolls.push('battle_staff');
      if(Math.random()<0.06) rolls.push('ring_gold');
    }
    // Global rare gem drop ~1.5%
    if(Math.random()<0.015){ const gems=['t7','g7','r7','s7','emerald7']; rolls.push(gems[(Math.random()*gems.length)|0]); }
    // Enforce map gating for gear drops
    const filtered = rolls.filter(id=> itemAllowedInMap(ITEM_DB[id]));
    for(const id of filtered){ if(id==='potion_hp' || id==='potion_mp'){ drops.push({x:m.x+rand(-12,12), y:m.y+rand(-12,12), t:0, item:id, stack: (Math.random()<0.5?2:1)}); } else { drops.push({x:m.x+rand(-12,12), y:m.y+rand(-12,12), t:0, item:id}); } }
  }

  // Buff Fairies ‚Äî spawn around player every 5 levels
  function spawnBuffFairies(){
    const defs=[
      {icon:'üó°Ô∏è', desc:'Attack Power +8 (120s)', apply:()=>({atk:8}), col:'#ffd24a', glyph:'üó°Ô∏è'},
      {icon:'üõ°Ô∏è', desc:'Defense +6 (120s)', apply:()=>({def:6}), col:'#9cf', glyph:'üõ°Ô∏è'},
      {icon:'üí®', desc:'Move Speed +100 (120s)', apply:()=>({speed:100}), col:'#71e6a2', glyph:'üí®'},
      {icon:'üéØ', desc:'Accuracy +8% (120s)', apply:()=>({acc:0.08}), col:'#cfe', glyph:'üéØ'},
      {icon:'‚ú®', desc:'Critical Chance +8% (120s)', apply:()=>({crit:0.08}), col:'#f9c', glyph:'‚ú®'},
    ];
    let angle=0;
    defs.forEach((d,i)=>{
      const a = angle + i*(Math.PI*2/defs.length);
      const x = player.x + Math.cos(a)*60;
      const y = player.y + Math.sin(a)*60;
      // Visual fairy FX
      fx.push({t:6, kind:'fairy', x, y, seed:Math.random()*10, col:d.col, glyph:d.glyph});
      // On-touch pickup
      setTimeout(()=>{
        // Grant buff immediately on spawn and show icon in HUD
        const buff = Object.assign({t:120, icon:d.icon, desc:d.desc}, d.apply());
        player.buffs.push(buff);
        recalcStats(); notify('Fairy Blessing: '+d.desc);
      }, 300 + i*150);
    });
  }

  function questKillCredit(type){
    const q = quests[qIndex]; if(!q || q.done) return;
    if(q.type===type || (q.type==='eldeon_kill' && (type==='spirit_archer'||type==='thornling'))){
      q.prog = (q.prog||0)+1;
      if(q.prog >= q.need){
        q.done = true;
        const rw = q.reward||{};
        if(rw.xp) grantXP(rw.xp);
        if(rw.gold){ player.gold = (player.gold|0) + rw.gold; }
        if(rw.items){ rw.items.forEach(([id,qty])=> addToInv(id, qty||1)); }
        notify('Quest complete: '+q.title + ' ‚Äî Rewards: ' + rewardText(q));
        save();
        if(qIndex < quests.length-1) qIndex++;
      } else { save(); }
    }
  }

  function onMobKilled(m){
    const baseXP = (m.boss? 120 : (m.type==='pumpkin'? 18 : m.type==='flanae'? 20 : 14));
    const baseG  = (m.boss? [60,120] : (m.type==='pumpkin'? [8,16] : m.type==='flanae'? [8,14] : [6,12]));
    grantXP(baseXP);
    dropGold(m.x, m.y, baseG[0], baseG[1]);
    questKillCredit(m.type);
    if(cartQuest.active && m.type==='pumpkin'){ cartQuest.pumpkins++; save(); }
    dropItemRoll(m);
  }

  // PATCH 3: Cart quest gating
  function interactCartMaster(){
    const q = quests.find(q=>q.id===3);
    if(q && q.done){ notify("You're licensed. Press C to summon a cart."); return; }
    if(!cartQuest.active){ notify(`Cart License quest started: pay ${cartQuest.fee}‚ú¶ and defeat ${cartQuest.needPumpkins} Pumpkins.`); cartQuest.active = true; cartQuest.pumpkins = 0; save(); return; }
    if(!cartQuest.paid){ if((player.gold|0) >= cartQuest.fee){ player.gold -= cartQuest.fee; cartQuest.paid = true; notify('Fee paid. Now defeat '+cartQuest.needPumpkins+' Pumpkins.'); save(); } else { notify('You need '+(cartQuest.fee - (player.gold|0))+' more gold for the fee.'); } return; }
    if(cartQuest.pumpkins >= cartQuest.needPumpkins){ addToInv('cart_pass',1); player.flags.cartUnlocked = true; const q3 = quests.find(x=>x.id===3); if(q3){ q3.done = true; if(qIndex<quests.length-1) qIndex++; } notify('Cart License acquired! Press C to summon, E near cart to mount.'); save(); } else { notify(`Progress: ${cartQuest.pumpkins}/${cartQuest.needPumpkins} Pumpkins defeated.`); }
  }

  function mountCart(){ if(!player.flags.cartUnlocked){ notify('Finish Cart License first.'); return; } player.mounted = !player.mounted; if(player.mounted){ notify('Mounted cart! Speed up.'); } else { notify('Dismounted.'); } recalcStats(); mountChip.style.display = player.mounted? 'inline-block':'none'; if(summonedCart && player.mounted) { summonedCart = null; } save(); }

  // Interact: sign
  function interactSign(){
    const q=quests.find(q=>q.id===0); if(!q) return;
    if(!q.done){ q.done=true; const rw=q.reward||{}; if(rw.xp) grantXP(rw.xp); if(rw.gold) player.gold=(player.gold|0)+rw.gold; if(rw.items) rw.items.forEach(([id,qty])=> addToInv(id, qty||1)); notify('Quest complete: '+q.title + ' ‚Äî Rewards: ' + rewardText(q)); if(qIndex<quests.length-1) qIndex++; save(); }
    else notify('Welcome back to Adventure Plains.');
  }

  function rewardText(obj){
    if(!obj) return '';
    const rw = obj.reward || {};
    const parts = [];
    if(rw.xp) parts.push(`${rw.xp} XP`);
    if(rw.gold!=null) parts.push(`${rw.gold}‚ú¶ Gold`);
    if(rw.items){ const is = rw.items.map(it=> (ITEM_DB[it[0]]? ITEM_DB[it[0]].name: it[0]) + (it[1]>1? ` x${it[1]}`:'')); if(is.length) parts.push(is.join(', ')); }
    return parts.join(' ¬∑ ');
  }

  function updateQuestText(){
    const q = quests[qIndex];
    if(!q){
      questLine.textContent='All quests complete!';
      questProg.textContent='';
      if(questReward) questReward.textContent='';
      return;
    }
    if(q.type==='talk'){
      questLine.textContent=q.line; questProg.textContent='';
    } else if(q.type==='level'){
      questLine.textContent=q.line; questProg.textContent=`Lv ${player.level}/${q.need}`;
    } else if(q.type==='travel'){
      // travel step: show destination and simple hint
      const dest = q.to || '';
      const label = dest==='luxem'? 'Luxem Forest' : dest==='zant'? 'Zant' : dest==='elverloon'? 'El Verloon Desert' : dest==='junon'? 'Junon Polis' : dest==='eldeon'? 'Eldeon Glade' : '';
      questLine.textContent = q.line || (`Travel to ${label}`);
      questProg.textContent = label? `Destination: ${label}` : '';
    } else if(q.type==='cartquest'){
      questLine.textContent=q.line; const prog = cartQuest.active? `${cartQuest.paid? 'Paid, ':''}${cartQuest.pumpkins}/${cartQuest.needPumpkins} pumpkins` : 'Talk to the Cart Master.'; questProg.textContent=prog;
    } else {
      questLine.textContent=q.title+': '+q.line; if(q.need){ questProg.textContent=`${q.prog||0}/${q.need}`; } else { questProg.textContent=''; }
    }
    if(questReward) questReward.textContent = 'Rewards: ' + rewardText(q) + ' ‚Äî spend gold at the Merchant (üõí).';
  }

  function dmgPlayer(d, kind){
    const reduction = (kind==='magic') ? (player.mdef||0) : (player.def||0);
    const final = Math.max(0, d - reduction);
    player.hp -= final;
    if(player.hp<0) player.hp= -1;
  }

  // Main loop
  let lt = now();
  function tick(){ const t = now(); const dt = Math.min(0.033, t-lt); lt=t; update(dt); draw(); requestAnimationFrame(tick); }

  function update(dt){
    updatePerf(dt);
    for(let i=player.buffs.length-1;i>=0;i--){ const b=player.buffs[i]; b.t-=dt; if(b.t<=0){ player.buffs.splice(i,1); recalcStats(); } }
    for(let i=0;i<4;i++){ if(player.skillCd[i]>0){ player.skillCd[i]-=dt; if(player.skillCd[i]<0) player.skillCd[i]=0; if(player.skillCd[i]===0) scds[i].style.display='none'; else { scds[i].style.display='grid'; scds[i].textContent= player.skillCd[i].toFixed(1); } } }

    // Movement
    let vx=0, vy=0;
    if(keys['w']||keys['arrowup']) vy-=1; if(keys['s']||keys['arrowdown']) vy+=1; if(keys['a']||keys['arrowleft']) vx-=1; if(keys['d']||keys['arrowright']) vx+=1;
    if(Math.hypot(joy.dx, joy.dy)>0.01){ vx += joy.dx*1.5; vy += joy.dy*1.5; }
    // Realistic-ish physics: acceleration and friction
    player.vx = (player.vx||0); player.vy = (player.vy||0);
    const mag=Math.hypot(vx,vy); if(mag>0){ vx/=mag; vy/=mag; }
    const accel = player.speed * 6.5; // acceleration coefficient
    const maxSpeed = player.speed;
    player.vx += vx*accel*dt; player.vy += vy*accel*dt;
    // Apply friction when no input
    const friction = 4.2; player.vx -= player.vx*friction*dt; player.vy -= player.vy*friction*dt;
    // Clamp to max speed
    const spd=Math.hypot(player.vx,player.vy); if(spd>maxSpeed){ const s=maxSpeed/spd; player.vx*=s; player.vy*=s; }
    let nx = player.x + player.vx*dt; let ny = player.y + player.vy*dt; if(!blocked(nx, player.y)) player.x=nx; if(!blocked(player.x, ny)) player.y=ny;
    // Player faces last movement or firing direction, not the mouse, for immersion
    if(vx!==0 || vy!==0){ player.dir = Math.atan2(vy, vx); }

    // Camera follow
    camera.x = clamp(player.x - vw/2, 0, MAP_W*TILE - vw); camera.y = clamp(player.y - vh/2, 0, MAP_H*TILE - vh);

    // Attack
    player.atkTimer = Math.max(0, player.atkTimer - dt);
    const firing = mouse.down || keys[' ']===true;
    if(firing && player.atkTimer===0){ primaryAttack(); }

    // Interact (E)
    if(keys['e']){
      if(nearest(sign)<TILE*1.2){ interactSign(); keys['e']=false; }
      else if(nearest(merchant)<TILE*1.8){ openShop(); keys['e']=false; }
      else if(nearest(trainer)<TILE*1.8){ openJobs(); keys['e']=false; }
      // Map quest giver: press E near sign in non-plains maps to grab bounty
      else if(nearest(sign)<TILE*1.8 && mapName!=='plains'){ openMapBounties(); keys['e']=false; }
      else if(nearest(storageNPC)<TILE*1.8){ openStorage(); keys['e']=false; }
      // Plains: no Cart Master at spawn
      else if(summonedCart && nearest(summonedCart)<TILE*1.8){ mountCart(); keys['e']=false; }
      else {
        // Portals interaction
        for(const p of portals){ if(dist(player.x,player.y,p.x,p.y)<(p.r||22)){ changeMap(p.dest, p.tag||'main'); keys['e']=false; break; } }
      }
    }

    // Projectiles & turrets
  for(let i=projs.length-1;i>=0;i--){ const p=projs[i]; p.x+=p.vx*dt; p.y+=p.vy*dt; p.ttl-=dt; if(p.gravity) p.vy+=p.gravity*dt; if(p.ttl<=0){ const px=p.x,py=p.y; if(p.onExpire) p.onExpire(px,py); projs.splice(i,1); continue; } if(p.owner==='player'){ for(let j=ents.length-1;j>=0;j--){ const m=ents[j]; if(!m.alive) continue; if(dist(p.x,p.y,m.x,m.y)<m.r+6){ if(p.accRoll? rollHitAgainst(m) : true){ m.hp -= p.dmg; const dtype = (p.kind==='magic'||p.kind==='fire')? (p.kind) : 'physical'; showDamage(m.x,m.y,p.dmg,!!p.crit, dtype); m.hurt=0.15; } else { showMiss(m.x,m.y); } projs.splice(i,1); if(m.hp<=0){ m.alive=false; onMobKilled(m); ents.splice(j,1);} break; }} } else { if(dist(p.x,p.y,player.x,player.y)<player.r+6){ const kind = p.kind==='magic'? 'magic' : 'physical'; dmgPlayer(p.dmg, kind); projs.splice(i,1); } } }
    for(let i=turrets.length-1;i>=0;i--){ const t=turrets[i]; t.t-=dt; if(t.t<=0){ turrets.splice(i,1); continue; } if(Math.random()<0.06){ const m=ents.find(m=>m.alive && dist(t.x,t.y,m.x,m.y)<250); if(m){ const a=Math.atan2(m.y-t.y,m.x-t.x); shoot(t.x,t.y,a,player.atk*0.6,360,'player'); } } }

    // Mobs AI
  for(const m of ents){
      if(!m.alive) continue;
      // Keep mobs out of town zones
      if(isInTown(m.x, m.y)) { pushOutOfTown(m); m.aggro=0; }
      const d = dist(m.x,m.y,player.x,player.y);
      if(d<460){ m.aggro=1; }
      if(m.aggro){
        const a = Math.atan2(player.y-m.y, player.x-m.x);
        let mx = m.x + Math.cos(a)*m.speed*dt; let my = m.y + Math.sin(a)*m.speed*dt;
        if(!blocked(mx, m.y) && !isInTown(mx, m.y)) m.x=mx;
        if(!blocked(m.x, my) && !isInTown(m.x, my)) m.y=my;
        if(d<m.r+player.r+2 && !isInTown(player.x, player.y)){
          dmgPlayer( (m.type==='jelly'? 5 : m.type==='flanae'? 7 : 8)*dt );
        }
        // All mobs can attempt a basic magic bolt at range; bosses/ranged also keep their shots
        m.mcd = Math.max(0, (m.mcd||0) - dt);
        const wantRange = d>140 && d<520 && !isInTown(player.x, player.y);
        if(wantRange && m.mcd===0){
          const a2=Math.atan2(player.y-m.y,player.x-m.x);
          const dmg = (m.boss? 14 : 8);
          shoot(m.x,m.y,a2,dmg, (m.boss? 280:240), 'mob', 'magic');
          m.mcd = m.boss? 1.4 : 2.0;
        }
        if(m.type==='pumpkin' && Math.random()<0.006 && !isInTown(player.x, player.y)){
          const a3=Math.atan2(player.y-m.y,player.x-m.x); shoot(m.x,m.y,a3,8,220,'mob');
        }
        if(m.type==='jellyking' && Math.random()<0.006 && !isInTown(player.x, player.y)){
          const a4=Math.atan2(player.y-m.y,player.x-m.x); shoot(m.x,m.y,a4,14,260,'mob');
        }
        // Elite and boss micro-mechanics
        if(m.type==='woopie_elite' && Math.random()<0.004){
          // short leap + stun pulse
          const a5=Math.atan2(player.y-m.y,player.x-m.x); m.x+=Math.cos(a5)*40; m.y+=Math.sin(a5)*40; fx.push({t:0.22, kind:'burst', x:m.x, y:m.y, r:70}); if(dist(player.x,player.y,m.x,m.y)<70) dmgPlayer(12,'physical');
        }
        if(m.golem && Math.random()<0.003){
          // charged slam with telegraph
          fx.push({t:0.35, kind:'shock', x:m.x, y:m.y, r:90}); setTimeout(()=>{ if(dist(player.x,player.y,m.x,m.y)<90) dmgPlayer(24,'physical'); }, 360);
        }
        if(m.type==='choropy' && Math.random()<0.004){
          // dash-through
          const a6=Math.atan2(player.y-m.y,player.x-m.x); m.x+=Math.cos(a6)*60; m.y+=Math.sin(a6)*60; fx.push({t:0.18, kind:'wind', x:m.x, y:m.y, r:50, a:a6});
        }
        if(m.treant && Math.random()<0.004){
          // radial shots and add spawn
          for(let i=0;i<10;i++){ const ang=i*(Math.PI*2/10); shoot(m.x,m.y,ang,10,220,'mob','magic'); }
          // spawn adds
          for(let i=0;i<3;i++){ const ang=Math.random()*Math.PI*2; const rx=m.x+Math.cos(ang)*80, ry=m.y+Math.sin(ang)*80; spawnMob(Math.random()<0.5?'thornling':'spirit_archer', rx, ry); }
        }
      } else {
        m.x += (r()-0.5)*20*dt; m.y += (r()-0.5)*20*dt;
      }
      // Hopping update for jelly and jellyking
      if(m.type==='jelly' || m.type==='jellyking'){
        m.hopCd -= dt;
        // Only choose a new direction on takeoff
        if(m.hopCd<=0 && m.z===0){
          const a = Math.atan2(player.y-m.y, player.x-m.x) + (r()*0.8-0.4); // drift towards player
          const hopSpeed = m.boss? 64 : 70; // clearer forward travel during hops
          m.vx = Math.cos(a)*hopSpeed;
          m.vy = Math.sin(a)*hopSpeed;
          // Slightly higher/longer arc
          m.vz = (m.boss? 98: 88) + (r()*6-3);
          m.stretch = 0.10;
          m.hopCd = (m.boss? 1.05: 1.2) + Math.random()*0.35; // tiny bit longer between hops
        }
        // Air-time motion
        if(m.z>0 || m.vz>0){
          m.x += m.vx*dt*0.88; // travel while in air
          m.y += m.vy*dt*0.88;
        }
        // Gravity
        if(m.vz!==undefined){
          m.vz -= 610*dt; // a bit lighter gravity for slightly longer airtime
          m.z = Math.max(0, m.z + m.vz*dt);
          // snap only at the very end to avoid hover due to frame rounding
          if(m.z<1.2 && m.vz<8){ m.z=0; m.vz=0; }
          if(m.z===0 && m.vz<0){
            // landing squash
            m.squash = 0.14;
            m.vz = 0; m.vx*=0.6; m.vy*=0.6;
          }
        }
        // decay squash/stretch
        if(m.squash>0) m.squash = Math.max(0, m.squash - 1.0*dt);
        if(m.stretch>0) m.stretch = Math.max(0, m.stretch - 1.0*dt);
      }
      if(m.hurt>0) m.hurt-=dt; else m.hurt=0;
    }

    // Drops pickup
    for(let i=drops.length-1;i>=0;i--){ const d=drops[i]; d.t+=dt; if(dist(player.x,player.y,d.x,d.y)<28){ if(d.item){ addToInv(d.item, d.stack||1); notify('Picked: '+ITEM_DB[d.item].name); } if(d.gold){ player.gold+=d.gold; notify('+'+d.gold+' gold'); Sfx.play('gold'); } drops.splice(i,1); vibrate(10); } }

    // FX decay
    for(let i=fx.length-1;i>=0;i--){ fx[i].t-=dt; if(fx[i].t<=0) fx.splice(i,1); }

    // Death check
    if(player.hp<0){ player.hp=player.hpMax; player.x=startPos.x; player.y=startPos.y; player.mounted=false; mountChip.style.display='none'; notify('You fainted...'); vibrate(40); }

    // HUD update
    const nxf = xpFor(player.level); lvEl.textContent = `${player.level}/${MAX_LEVEL}`; goldEl.textContent = player.gold|0; shopGold.textContent = player.gold|0; jobEl.textContent=player.job;
    hpEl.style.width = (100*player.hp/player.hpMax)+'%'; mpEl.style.width = (100*player.mp/player.mpMax)+'%'; xpEl.style.width = (100*Math.min(player.xp/nxf,1))+'%'; nextxpEl.textContent = isFinite(nxf)? nxf : '‚Äî'; mountChip.style.display = player.mounted? 'inline-block':'none';
    updateQuestText();
    // Party HUD re-render (lightweight)
    renderPartyHud();
  }

  // ==== SECTION: DRAW PIPELINE via Renderer ====
  function draw(){
    Renderer.beginFrame();
    Renderer.draw.drawTiles();
    Renderer.draw.drawDecor();
    Renderer.draw.drawNPCs();
    Renderer.draw.drawMobs();
    Renderer.draw.drawProjs();
    Renderer.draw.drawPlayer();
    Renderer.draw.drawFX();
    Renderer.draw.drawOverlay();
    Renderer.endFrame();
    // HUD dynamic elements
    // Visual aim indicator
    try{
      const aim = getAimDir();
      const s = worldToScreen(player.x, player.y);
      const r1 = 18, r2 = 72;
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(aim);
      ctx.globalAlpha = 0.55;
      ctx.strokeStyle = 'rgba(200,240,255,0.8)';
      ctx.lineWidth = 2;
      ctx.beginPath(); ctx.moveTo(r1, 0); ctx.lineTo(r2, 0); ctx.stroke();
      ctx.globalAlpha = 0.35;
      ctx.beginPath(); ctx.arc(0,0, r1, -0.2, 0.2); ctx.stroke();
      ctx.restore();
    }catch(e){}
    // Name
    if(pnameEl) pnameEl.textContent = player.name||'Rosarian';
    // Buff icons
    if(buffbarEl){
      buffbarEl.innerHTML = '';
      for(const b of player.buffs){
        const span = document.createElement('span'); span.className='buff'; span.textContent = b.icon||'‚ú®'; span.title = b.desc||'Buff'; buffbarEl.appendChild(span);
      }
    }
  }

  // Backing implementations (Canvas for now)
  function drawTiles(){
    // tiles
    // Tiles
    const sx = Math.floor(camera.x/TILE), sy = Math.floor(camera.y/TILE); const ex = Math.ceil((camera.x+vw)/TILE), ey=Math.ceil((camera.y+vh)/TILE);
    for(let y=sy;y<ey;y++){
      for(let x=sx;x<ex;x++){
        if(x<0||y<0||x>=MAP_W||y>=MAP_H) continue; const t=tiles[y*MAP_W+x]; const px = x*TILE - camera.x; const py=y*TILE - camera.y;
        if(t===0){ // grass
          const g = ctx.createLinearGradient(0, py, 0, py+TILE);
          g.addColorStop(0, '#1b5a36'); g.addColorStop(1, '#124428');
          ctx.fillStyle = g; ctx.fillRect(px,py,TILE,TILE);
          // stripes + noise speckles for depth
          ctx.fillStyle = 'rgba(255,255,255,0.028)';
          for(let i=0;i<3;i++){ ctx.fillRect(px+4+i*16, py+2, 6, TILE-4); }
          ctx.fillStyle = 'rgba(0,0,0,0.03)';
          for(let i=0;i<4;i++){ const nx=px+Math.random()*TILE, ny=py+Math.random()*TILE; ctx.fillRect(nx,ny,1,1); }
        }else if(t===1){ // dirt or sand (map-dependent)
          if(mapName==='zant' || mapName==='elverloon'){
            // sandy tile with muted tones and dune shading
            const g = ctx.createLinearGradient(0, py, 0, py+TILE);
            g.addColorStop(0, '#b7954e'); g.addColorStop(1, '#8e7741');
            ctx.fillStyle = g; ctx.fillRect(px,py,TILE,TILE);
            // darker dune ridges
            ctx.fillStyle = 'rgba(0,0,0,0.07)';
            const wave = 10; const amp=1.6; const y0 = py + TILE*0.65;
            for(let xx=px; xx<px+TILE; xx+=wave){ const yy = y0 + Math.sin((xx*0.18)) * amp; ctx.fillRect(xx, Math.round(yy), wave-3, 2); }
          } else if(mapName==='plains'){
            // ROSE AP-style packed earth with light stone flecks
            const g = ctx.createLinearGradient(0, py, 0, py+TILE);
            g.addColorStop(0, '#b08c53'); g.addColorStop(1, '#967646');
            ctx.fillStyle = g; ctx.fillRect(px,py,TILE,TILE);
            // subtle flecks and seams
            ctx.fillStyle = 'rgba(255,255,255,0.06)';
            for(let i=0;i<2;i++){ ctx.fillRect(px+6+i*18, py+4, 4, TILE-8); }
            ctx.fillStyle = 'rgba(0,0,0,0.08)';
            const dots=6; for(let i=0;i<dots;i++){ const dx=px+4+Math.random()*(TILE-8), dy=py+4+Math.random()*(TILE-8); ctx.fillRect(dx,dy,1,1); }
          } else {
            ctx.fillStyle = '#6d5a35'; ctx.fillRect(px,py,TILE,TILE);
            ctx.strokeStyle = 'rgba(0,0,0,0.25)'; ctx.lineWidth=1; ctx.strokeRect(px+0.5,py+0.5,TILE-1,TILE-1);
            ctx.fillStyle='rgba(255,255,255,0.04)'; ctx.fillRect(px+3,py+3,TILE-6,TILE-6);
          }
        }else{ // water
          const g = ctx.createLinearGradient(0, py, 0, py+TILE);
          g.addColorStop(0, '#2e7da3'); g.addColorStop(1, '#1f5a74');
          ctx.fillStyle = g; ctx.fillRect(px,py,TILE,TILE);
          ctx.fillStyle = 'rgba(255,255,255,0.08)';
          const w = 8, amp=2, y0 = py + (TILE*0.3);
          for(let xx=px; xx<px+TILE; xx+=w){
            const yy = y0 + Math.sin((xx*0.2) + performance.now()/500)*amp;
            ctx.fillRect(xx, Math.round(yy), w-2, 2);
          }
        }
      }
    }
  }
  function drawDecor(){
    // Decor
    for(const d of decor){
      const s=worldToScreen(d.x,d.y); if(s.x<-50||s.y<-50||s.x>vw+50||s.y>vh+50) continue;
      if(d.t==='tree'){
        // Trunk
        ctx.fillStyle = '#7a5a3a';
        ctx.fillRect(s.x-4, s.y-18, 8, 22);
        ctx.fillStyle = 'rgba(0,0,0,0.15)';
        ctx.fillRect(s.x-4, s.y-18, 8, 2);
        // Layered canopy (ROSE-like round leaves, multi-tone)
        const drawBlob=(dx,dy,r,col)=>{ ctx.fillStyle=col; ctx.beginPath(); ctx.arc(s.x+dx, s.y-22+dy, r, 0, Math.PI*2); ctx.fill(); };
        drawBlob(0, 0, 22, '#2f6a43');
        drawBlob(-10,-6,18, '#29613b');
        drawBlob(12,-8,16, '#33724a');
        drawBlob(-4,10,16, '#2a5d3d');
      } else if(d.t==='rock'){
        ctx.fillStyle = (mapName==='zant'||mapName==='elverloon')? '#5b5242':'#3b4653';
        ctx.beginPath(); ctx.arc(s.x,s.y,10,0,6.28); ctx.fill();
      } else if(d.t==='plaza'){
        // Circular stone plaza floor around bonfire
        const r = d.r || TILE*6;
        const steps = 18; // radial seams
        // base disk
        const grad = ctx.createRadialGradient(s.x,s.y, r*0.1, s.x,s.y, r);
        grad.addColorStop(0,'#d8c8a6'); grad.addColorStop(1,'#b8a782');
        ctx.fillStyle = grad; ctx.beginPath(); ctx.arc(s.x, s.y, r, 0, Math.PI*2); ctx.fill();
        // radial seams
        ctx.strokeStyle = 'rgba(100,80,50,0.25)'; ctx.lineWidth=1;
        for(let i=0;i<steps;i++){ const a=(i/steps)*Math.PI*2; ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x+Math.cos(a)*r, s.y+Math.sin(a)*r); ctx.stroke(); }
        // ring seams
        ctx.strokeStyle='rgba(255,255,255,0.15)';
        for(let rr=r*0.25; rr<r; rr+=TILE*1.2){ ctx.beginPath(); ctx.arc(s.x, s.y, rr, 0, Math.PI*2); ctx.stroke(); }
      } else if(d.t==='bld'){
        // ROSE AP-like clay/plaster buildings with colored roofs
        const w=(d.w||TILE*4), h=(d.h||TILE*3);
        const x0=s.x - w/2, y0=s.y - h/2;
        // walls (warm plaster)
        ctx.fillStyle = d.wall || '#e8d2b0';
        ctx.fillRect(x0, y0, w, h);
        // door and lintel
        const doorW= Math.max(16, Math.min(28, w*0.22));
        ctx.fillStyle=d.door || '#6a4422'; ctx.fillRect(x0 + w/2 - doorW/2, y0 + h - 22, doorW, 20);
        ctx.fillStyle='rgba(0,0,0,0.25)'; ctx.fillRect(x0 + w/2 - doorW/2, y0 + h - 24, doorW, 3);
        // roof (colored tile cap)
        const roofH = Math.max(10, h*0.22);
        const roofCol = d.roof || '#a84f3c';
        ctx.fillStyle = roofCol;
        ctx.fillRect(x0-2, y0-2, w+4, roofH+4);
        // roof ridge pattern
        ctx.fillStyle = 'rgba(255,255,255,0.10)';
        for(let rx=x0; rx<x0+w; rx+=12){ ctx.fillRect(rx+4, y0+2, 6, 2); }
        // outline
        ctx.strokeStyle='rgba(0,0,0,0.35)'; ctx.lineWidth=2; ctx.strokeRect(x0+0.5, y0+0.5, w-1, h-1);
        // small windows
        ctx.fillStyle = '#5b6b7a';
        ctx.fillRect(x0+10, y0+roofH+8, 10, 10);
        ctx.fillRect(x0+w-20, y0+roofH+8, 10, 10);
      } else if(d.t==='stall'){
        // Merchant/trainer canopy stall
        const w = d.w || TILE*2.2, h = d.h || TILE*1.2;
        const x0=s.x - w/2, y0=s.y - h/2;
        // posts
        ctx.fillStyle = '#7a5a32';
        ctx.fillRect(x0+4, y0, 4, h);
        ctx.fillRect(x0+w-8, y0, 4, h);
        // canopy
        const col = d.col || '#c95a4a';
        ctx.fillStyle = col; ctx.fillRect(x0, y0-6, w, 12);
        ctx.fillStyle = 'rgba(255,255,255,0.12)'; ctx.fillRect(x0+6, y0-4, w-12, 4);
      } else if(d.t==='bonfire'){
        // Central bonfire with animated flame and glow
        const t = performance.now()/1000;
        const bob = Math.sin(t*6 + (d.x+d.y)*0.01)*2;
        // base stones
        ctx.fillStyle='#3a2c12'; ctx.beginPath(); ctx.ellipse(s.x, s.y+6, 18, 10, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle='#4a3920'; ctx.beginPath(); ctx.ellipse(s.x-10, s.y+8, 6, 4, 0, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(s.x+10, s.y+7, 6, 4, 0, 0, Math.PI*2); ctx.fill();
        // flame core
        const grd = ctx.createRadialGradient(s.x, s.y-6+bob, 4, s.x, s.y-6+bob, 18);
        grd.addColorStop(0,'rgba(255,230,140,0.95)');
        grd.addColorStop(0.5,'rgba(255,160,60,0.75)');
        grd.addColorStop(1,'rgba(255,120,40,0)');
        ctx.fillStyle = grd; ctx.beginPath(); ctx.arc(s.x, s.y-6+bob, 18, 0, Math.PI*2); ctx.fill();
        // flame body
        ctx.fillStyle='#ffa24a'; ctx.beginPath(); ctx.ellipse(s.x, s.y-6+bob, 8, 14, 0, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle='#ffd24a'; ctx.beginPath(); ctx.ellipse(s.x, s.y-10+bob, 5, 8, 0, 0, Math.PI*2); ctx.fill();
      } else if(d.t==='pillar'){
        // Standing stone pillar (spawn ring)
        const w = 10, h = 30; const x0 = s.x - w/2, y0 = s.y - h;
        ctx.fillStyle = '#8a7a62'; ctx.fillRect(x0, y0, w, h);
        ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fillRect(x0, y0, w, 3);
        ctx.strokeStyle='rgba(0,0,0,0.25)'; ctx.strokeRect(x0+0.5, y0+0.5, w-1, h-1);
      } else if(d.t==='gate'){
        // Canyon gate: two larger pillars flanking the road
        const gap = TILE*1.8; const pw=14, ph=42;
        ctx.fillStyle = '#9a8a72';
        ctx.fillRect(s.x-gap/2 - pw, s.y-ph, pw, ph);
        ctx.fillRect(s.x+gap/2,      s.y-ph, pw, ph);
        ctx.fillStyle = 'rgba(0,0,0,0.2)';
        ctx.fillRect(s.x-gap/2 - pw, s.y-ph, pw, 3);
        ctx.fillRect(s.x+gap/2,      s.y-ph, pw, 3);
      } else if(d.t==='cactus'){
        // simple saguaro
        ctx.fillStyle='#3f7d3a';
        ctx.fillRect(s.x-5, s.y-24, 10, 28);
        ctx.fillRect(s.x-14, s.y-14, 6, 14);
        ctx.fillRect(s.x+8, s.y-16, 6, 16);
        ctx.fillStyle='rgba(255,255,255,0.25)';
        for(let i=0;i<3;i++){ ctx.fillRect(s.x-4+i*3, s.y-22, 1, 24); }
      } else if(d.t==='bones'){
        ctx.strokeStyle='#e9e1d1'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(s.x-10, s.y); ctx.lineTo(s.x+10, s.y); ctx.stroke();
        ctx.fillStyle='#e9e1d1'; ctx.beginPath(); ctx.arc(s.x-12, s.y, 3, 0, Math.PI*2); ctx.arc(s.x+12, s.y, 3, 0, Math.PI*2); ctx.fill();
      } else {
        ctx.fillStyle='#8fd3a0'; ctx.fillRect(s.x-2,s.y-2,4,4);
      }
    }
  }
  function drawNPCs(){
    // replaced by sprite-based draws (Patch 2) but keep calls grouped
    drawNPCSprites();
  }
  function drawMobsSorted(){
    // depth-sort mobs + drops and render
    const visibleMobs = [];
    for(const m of ents){ if(!m.alive) continue; const s=worldToScreen(m.x,m.y); if(s.x<-40||s.y<-40||s.x>vw+40||s.y>vh+40) continue; visibleMobs.push({m, sy:s.y}); }
    visibleMobs.sort((a,b)=>a.sy-b.sy);
    for(const v of visibleMobs){ drawMobSprite(v.m); }
    // Drops (gold icons)
    for(const d of drops){ if(d.gold){ const s=worldToScreen(d.x,d.y); ctx.save(); ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.font='22px system-ui'; const goldCol = getComputedStyle(document.documentElement).getPropertyValue('--gold') || '#f1c40f'; const bob = Math.sin(performance.now()/200 + d.x*0.05)*3; ctx.shadowColor = 'rgba(241,196,15,0.75)'; ctx.shadowBlur = 18; ctx.fillStyle= goldCol; ctx.fillText('‚ú¶', s.x, s.y - 6 + bob); ctx.restore(); } }
  }
  function drawProjectilesStage(){ for(const p of projs){ drawProjectile(p); } }
  function drawFXStage(){
    // FX simple trails and damage numbers
    ctx.fillStyle='rgba(255,255,255,0.25)';
    for(const f of fx){
      if(f.kind==='trail'){
        const s=worldToScreen(f.x,f.y); ctx.beginPath(); ctx.arc(s.x,s.y,3,0,6.28); ctx.fill();
      } else if(f.kind==='hit'){
        const s=worldToScreen(f.x,f.y);
        ctx.save();
        const a = Math.max(0, Math.min(1, f.t/0.18));
        ctx.globalAlpha = 0.9 * a;
        ctx.strokeStyle = '#ffd24a'; ctx.lineWidth=2;
        ctx.beginPath(); ctx.moveTo(s.x-6, s.y); ctx.lineTo(s.x+6, s.y); ctx.moveTo(s.x, s.y-6); ctx.lineTo(s.x, s.y+6); ctx.stroke();
        ctx.restore();
      } else if(f.kind==='arc'){
        const s=worldToScreen(f.x,f.y); ctx.strokeStyle='rgba(255,255,255,0.2)'; ctx.beginPath(); ctx.arc(s.x,s.y,f.r, f.a-0.9, f.a+0.9); ctx.stroke();
      } else if(f.kind==='boom'){
        const s=worldToScreen(f.x,f.y); ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.beginPath(); ctx.arc(s.x,s.y,24,0,6.28); ctx.stroke();
      } else if(f.kind==='slash'){
        const s=worldToScreen(f.x,f.y); ctx.save();
        ctx.translate(s.x, s.y); ctx.rotate(f.a);
        // bright core
        ctx.globalAlpha = 0.8 * (f.t/0.22);
        const grd = ctx.createLinearGradient(0,0,f.r,0); grd.addColorStop(0,'#e8f5ff'); grd.addColorStop(1,'rgba(200,240,255,0)');
        ctx.strokeStyle = grd; ctx.lineWidth = 6; ctx.beginPath(); ctx.arc(0,0,f.r, -0.9, 0.2); ctx.stroke();
        // soft outer glow
        ctx.globalAlpha = 0.5 * (f.t/0.22); ctx.strokeStyle='rgba(150,210,255,0.6)'; ctx.lineWidth=12; ctx.beginPath(); ctx.arc(0,0,f.r*0.96, -0.95, 0.25); ctx.stroke();
        ctx.restore();
      } else if(f.kind==='dmg'){
        const s=worldToScreen(f.x,f.y);
        const life = f.t; const alpha = Math.max(0, Math.min(1, life/0.9));
        const rise = (1 - alpha) * 28;
        ctx.save();
        ctx.font = f.crit? 'bold 28px system-ui' : '22px system-ui';
        ctx.textAlign='center'; ctx.textBaseline='middle';
        ctx.fillStyle = f.crit? '#ffd24a' : '#e6eef7';
        ctx.globalAlpha = 0.85*alpha;
        // Damage type icon
        let icon = '';
        if(f.dtype==='magic') icon = '‚ú®'; else if(f.dtype==='fire') icon = 'üî•'; else icon = '‚öîÔ∏è';
        ctx.fillText(icon+ ' ' + String(f.val), s.x, s.y - 10 - rise);
        ctx.restore();
      } else if(f.kind==='miss'){
        const s=worldToScreen(f.x,f.y);
        ctx.save(); ctx.font='bold 18px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle='#ff8b73'; ctx.globalAlpha=0.9; ctx.fillText('MISS', s.x, s.y-22); ctx.restore();
      } else if(f.kind==='whirl'){
        const s=worldToScreen(f.x,f.y); const a = Math.min(1, f.t/0.25);
        ctx.save(); ctx.globalAlpha = 0.75*a; const grad = ctx.createRadialGradient(s.x,s.y,10, s.x,s.y,f.r);
        grad.addColorStop(0,'rgba(220,240,255,0.8)'); grad.addColorStop(1,'rgba(220,240,255,0)');
        ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(s.x,s.y,f.r,0,Math.PI*2); ctx.fill();
        ctx.restore();
      } else if(f.kind==='wind'){
        const s=worldToScreen(f.x,f.y); ctx.save(); ctx.globalAlpha = 0.65*(f.t/0.22);
        ctx.translate(s.x,s.y); ctx.rotate(f.a||0);
        for(let i=0;i<6;i++){
          ctx.rotate(Math.PI/3);
          const grd = ctx.createLinearGradient(0,0,f.r,0); grd.addColorStop(0,'rgba(180,230,255,0.9)'); grd.addColorStop(1,'rgba(180,230,255,0)');
          ctx.strokeStyle = grd; ctx.lineWidth = 10; ctx.beginPath(); ctx.arc(0,0,f.r*0.9, -0.8, 0.8); ctx.stroke();
        }
        ctx.restore();
      } else if(f.kind==='burst'){
        const s=worldToScreen(f.x,f.y); ctx.save(); ctx.globalAlpha=0.7*(f.t/0.28);
        ctx.strokeStyle='rgba(255,210,100,0.8)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(s.x,s.y,f.r,0,Math.PI*2); ctx.stroke(); ctx.restore();
      } else if(f.kind==='shock'){
        const s=worldToScreen(f.x,f.y); ctx.save(); ctx.globalAlpha = 0.6*(f.t/0.25); ctx.strokeStyle='rgba(120,180,255,0.9)'; ctx.lineWidth=5; ctx.beginPath(); ctx.arc(s.x,s.y,f.r,0,Math.PI*2); ctx.stroke(); ctx.restore();
      } else if(f.kind==='spray'){
        const s=worldToScreen(f.x,f.y); ctx.save(); ctx.globalAlpha=0.6*(f.t/0.22); ctx.strokeStyle='rgba(255,210,100,0.85)';
        for(let k=0;k<14;k++){ const ang = (k/14)*Math.PI*2; const len = f.r*(0.6+0.4*Math.random()); ctx.beginPath(); ctx.moveTo(s.x, s.y); ctx.lineTo(s.x+Math.cos(ang)*len, s.y+Math.sin(ang)*len); ctx.stroke(); }
        ctx.restore();
      } else if(f.kind==='nova'){
        const s=worldToScreen(f.x,f.y); ctx.save(); ctx.globalAlpha=0.7*(f.t/0.3); const grad = ctx.createRadialGradient(s.x,s.y,12, s.x,s.y,f.r);
        grad.addColorStop(0,'rgba(200,160,255,0.9)'); grad.addColorStop(1,'rgba(200,160,255,0)'); ctx.fillStyle=grad; ctx.beginPath(); ctx.arc(s.x,s.y,f.r,0,Math.PI*2); ctx.fill(); ctx.restore();
      } else if(f.kind==='fairy'){
        const s=worldToScreen(f.x,f.y);
        const bob = Math.sin(performance.now()/400 + f.seed)*4;
        ctx.save();
        ctx.globalAlpha = 0.85;
        ctx.fillStyle = f.col || '#cfa';
        ctx.beginPath(); ctx.arc(s.x, s.y - 20 + bob, 8, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff'; ctx.font='12px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(f.glyph||'‚ú®', s.x, s.y - 20 + bob);
        ctx.restore();
      }
    }
    // Job trainer guide arrow
    if(jobArrow.active){
      const s=worldToScreen(trainer.x, trainer.y);
      // Clamp to screen edges with padding
      const pad=20; let ax=clamp(s.x, pad, vw-pad), ay=clamp(s.y, pad, vh-pad);
      const a = Math.atan2(ay - (vh-70), ax - 40); // direction from minimap area
      ctx.save();
      ctx.translate(ax, ay);
      ctx.rotate(a);
      ctx.fillStyle='rgba(255,255,255,0.9)';
      ctx.beginPath(); ctx.moveTo(0,0); ctx.lineTo(-16,6); ctx.lineTo(-16,-6); ctx.closePath(); ctx.fill();
      ctx.restore();
    }

    // Minimap render
    if(mapCtx){
      mapCtx.clearRect(0,0,minimapCanvas.width,minimapCanvas.height);
      const mmW=minimapCanvas.width, mmH=minimapCanvas.height;
      mapCtx.fillStyle='rgba(255,255,255,0.06)'; mapCtx.fillRect(0,0,mmW,mmH);
      // Map tiles overview
      const scaleX = mmW/(MAP_W*TILE); const scaleY=mmH/(MAP_H*TILE);
      for(let y=0;y<MAP_H;y++){
        for(let x=0;x<MAP_W;x++){
          const t=tiles[y*MAP_W+x];
          if(t===1){ mapCtx.fillStyle='rgba(255,255,255,0.14)'; }
          else if(t===2){ mapCtx.fillStyle='rgba(80,160,200,0.8)'; }
          else { mapCtx.fillStyle='rgba(120,180,120,0.2)'; }
          mapCtx.fillRect(x*TILE*scaleX, y*TILE*scaleY, TILE*scaleX, TILE*scaleY);
        }
      }
      const drawDot=(x,y,color,r)=>{ mapCtx.fillStyle=color; mapCtx.beginPath(); mapCtx.arc(x*scaleX, y*scaleY, r, 0, Math.PI*2); mapCtx.fill(); };
      drawDot(player.x, player.y, '#71e6a2', 4);
      drawDot(merchant.x, merchant.y, '#f1c40f', 4.5);
      drawDot(trainer.x, trainer.y, '#ffffff', 4.5);
      if(summonedCart) drawDot(summonedCart.x, summonedCart.y, '#6cf', 3.5);
      // Quest marker (!) above NPC if a quest is available
      const questNpc = (qIndex===0? sign : (qIndex===3? cartMaster : (qIndex===4? trainer : null)));
      if(questNpc){ mapCtx.fillStyle='#ffd24a'; mapCtx.font='bold 12px system-ui'; mapCtx.textAlign='center'; mapCtx.fillText('!', questNpc.x*scaleX, questNpc.y*scaleY-8); }
      // camera rectangle
      mapCtx.strokeStyle='rgba(255,255,255,0.35)'; mapCtx.lineWidth=1;
      mapCtx.strokeRect(camera.x*scaleX, camera.y*scaleY, vw*scaleX, vh*scaleY);
      // Minimap label: map name + level range
      if(minimapLabel){ const lbl = (mapName==='plains')? 'Adventure Plains' : (mapName==='zant'? 'Zant' : (mapName==='junon'? 'Junon Polis' : (mapName==='elverloon'? 'El Verloon Desert' : (mapName==='luxem'? 'Luxem Forest' : (mapName==='canyon'? 'Gorge Canyon' : (mapName==='luna'? 'Luna' : (mapName==='eldeon'? 'Eldeon Glade' : ''))))))); const range = MAP_ITEM_LEVELS[mapName] || [1, MAX_LEVEL]; minimapLabel.textContent = `${lbl}${lbl? ' ¬∑ ':''}Lv ${range[0]}‚Äì${range[1]}`; }
    }
  }

  // Sprite helpers (PATCH 4)
  // Small color utilities for bean shading (no external deps)
  function hexToRgb(h){ const n=h.replace('#',''); const v=n.length===3? n.split('').map(c=>parseInt(c+c,16)) : [parseInt(n.slice(0,2),16),parseInt(n.slice(2,4),16),parseInt(n.slice(4,6),16)]; return {r:v[0],g:v[1],b:v[2]}; }
  function clamp01(x){ return Math.max(0, Math.min(1, x)); }
  function lighten(hex, amt){ const {r,g,b}=hexToRgb(hex); const f=t=>Math.round(255 - (255-t)*(1-amt)); return `rgb(${f(r)},${f(g)},${f(b)})`; }
  function shade(hex, amt){ const {r,g,b}=hexToRgb(hex); const f=t=>Math.round(t*(1-amt)); return `rgb(${f(r)},${f(g)},${f(b)})`; }
  function drawPlayer(){
    const s = worldToScreen(player.x, player.y);
    // Soft blob shadow with depth based on vertical position for fake 3D grounding
    ctx.fillStyle = 'rgba(0,0,0,0.35)'; ctx.beginPath(); ctx.ellipse(s.x, s.y+16, 16, 8, 0, 0, Math.PI*2); ctx.fill();
    ctx.save(); ctx.translate(s.x, s.y);
    // Body tilt towards aim for depth
    const aim = getAimDir(); const tilt = Math.sin(aim)*0.08; ctx.rotate(tilt);
    // Wings (draw behind body)
    if(player.eq && player.eq.wings){
      ctx.save();
      const style = player.appearance?.wingsStyle || ITEM_DB[player.eq.wings]?.style || 'butterfly';
      const ref = (ITEM_DB[player.eq.wings]?.refine|0) || 0;
      ctx.globalAlpha = 0.92;
      if(style==='angel'){
        ctx.fillStyle = 'rgba(240,245,255,0.95)';
        for(let i=0;i<3;i++){
          ctx.beginPath(); ctx.ellipse(-12 - i*10, -6 - i*4, 14-i*2, 10-i*2, -0.4, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.ellipse(-12 - i*10,  8 + i*4, 14-i*2, 10-i*2,  0.4, 0, Math.PI*2); ctx.fill();
        }
        ctx.strokeStyle='rgba(180,190,210,0.9)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(-10,-14); ctx.lineTo(-40,0); ctx.lineTo(-10,14); ctx.stroke();
      } else if(style==='bat'){
        ctx.fillStyle = '#4b2a4a';
        ctx.beginPath(); ctx.moveTo(-10,-10); ctx.quadraticCurveTo(-34,-6, -46,0); ctx.quadraticCurveTo(-30,6, -10,12); ctx.closePath(); ctx.fill();
        ctx.strokeStyle='rgba(0,0,0,0.5)'; ctx.stroke();
      } else if(style==='feather'){
        ctx.fillStyle = '#e8eef6';
        for(let i=0;i<4;i++){ ctx.beginPath(); ctx.ellipse(-14 - i*8, 2 + i*3, 10, 6, 0.5, 0, Math.PI*2); ctx.fill(); }
        ctx.strokeStyle='rgba(160,170,190,0.9)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(-10,-12); ctx.lineTo(-42,2); ctx.lineTo(-10,14); ctx.stroke();
      } else if(style==='mechanical'){
        ctx.fillStyle = '#667'; ctx.beginPath(); ctx.ellipse(-22,0,16,10,0.3,0,Math.PI*2); ctx.fill(); ctx.fillStyle='#889'; ctx.beginPath(); ctx.ellipse(-36,2,12,8,-0.2,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle='#ccd'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(-10,-8); ctx.lineTo(-36,0); ctx.lineTo(-10,8); ctx.stroke();
      } else if(style==='fairy'){
        const t = performance.now()/800; const flap = Math.sin(t)*0.2;
        ctx.fillStyle = '#aef'; ctx.beginPath(); ctx.ellipse(-18, -8, 18, 12, -0.6+flap, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fb9'; ctx.beginPath(); ctx.ellipse(-30,  8, 16, 10,  0.6-flap, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(-10,-12); ctx.lineTo(-36,-2); ctx.lineTo(-10,12); ctx.stroke();
      } else {
        const t = performance.now()/800; const flap = Math.sin(t)*0.2;
        ctx.fillStyle = '#ff9ad6'; ctx.beginPath(); ctx.ellipse(-16, -8, 18, 12, -0.6+flap, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(-16,  10, 18, 12,  0.6-flap, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#6cc9ff'; ctx.beginPath(); ctx.ellipse(-30, -4, 14, 10, -0.6+flap, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.ellipse(-30,  6, 14, 10,  0.6-flap, 0, Math.PI*2); ctx.fill();
        ctx.strokeStyle='rgba(255,255,255,0.6)'; ctx.lineWidth=1; ctx.beginPath(); ctx.moveTo(-10,-12); ctx.lineTo(-36,-2); ctx.lineTo(-10,12); ctx.stroke();
      }
      // glow increases with refine
      if(ref>0){ const g=ctx.createRadialGradient(-18,0,8,-18,0,24); g.addColorStop(0,'rgba(200,240,255,'+(0.15+ref*0.04)+')'); g.addColorStop(1,'rgba(200,240,255,0)'); ctx.fillStyle=g; ctx.beginPath(); ctx.ellipse(-18,0,28,22,0,0,Math.PI*2); ctx.fill(); }
      ctx.restore();
    }
    // 3D-ish shaded body with subtle rim light and faux normal shading
    const outfit = player.appearance?.outfit || '#2a6aa8';
    const skin = player.appearance?.skin || '#f2d6c2';
    const gBody = ctx.createLinearGradient(-12, -30, 12, 16); gBody.addColorStop(0, outfit); gBody.addColorStop(1, '#13283d');
    ctx.fillStyle = gBody; ctx.beginPath(); ctx.roundRect(-10, -14, 20, 28, 4); ctx.fill();
    const gHead = ctx.createRadialGradient(0, -26, 2, 0, -24, 10); gHead.addColorStop(0, '#fff6'); gHead.addColorStop(1, skin);
    ctx.fillStyle = gHead; ctx.beginPath(); ctx.arc(0, -24, 8, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#334'; ctx.fillRect(-10, 10, 8, 10); ctx.fillRect(2, 10, 8, 10);
    // Helmet visual if equipped
    if(player.eq && player.eq.helmet){
      ctx.fillStyle = '#9ab';
      ctx.beginPath(); ctx.arc(0, -26, 9, Math.PI, Math.PI*2); ctx.fill();
      ctx.fillRect(-9, -26, 18, 4);
    }
    // Arms with skin tone
    ctx.fillStyle = skin; ctx.fillRect(10, -10, 10, 6); ctx.fillRect(-20, -10, 10, 6);
    const wep = getEquippedWeaponType();
    // Animate melee swing tilt
    const tNow = performance.now()/1000; if(player.swingT>0) player.swingT = Math.max(0, player.swingT-0.016);
    const swing = Math.sin((1-player.swingT)*Math.PI)*0.5;
    ctx.save(); ctx.rotate(aim + (wep==='sword'||wep==='katar'? (swing*0.5):0));
    ctx.translate(0,0);
    ctx.fillStyle = '#d9d9d9';
    if(wep==='sword'){ ctx.fillRect(14, -14, 4, 26); ctx.fillRect(10, -12, 12, 4); }
    else if(wep==='bow'){ ctx.strokeStyle = '#cfa'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(16, -16); ctx.quadraticCurveTo(28, 0, 16, 16); ctx.stroke(); }
    else if(wep==='gun'){ ctx.fillStyle='#444'; ctx.fillRect(10,-6,16,6); ctx.fillStyle='#222'; ctx.fillRect(12,0,6,8); }
    else if(wep==='katar'){ ctx.fillRect(12, -6, 12, 4); ctx.fillRect(12, 2, 12, 4); }
    else if(wep==='staff'){ ctx.fillStyle = '#b98f5a'; ctx.fillRect(8, -22, 6, 40); ctx.fillStyle = '#fa6'; ctx.beginPath(); ctx.arc(11, -24, 6, 0, Math.PI*2); ctx.fill(); }
    else if(wep==='wand'){ ctx.fillStyle = '#b98f5a'; ctx.fillRect(12, -10, 6, 22); ctx.fillStyle = '#f6f'; ctx.beginPath(); ctx.arc(15, -12, 4, 0, Math.PI*2); ctx.fill(); }
    else if(wep==='fist'){ ctx.fillStyle = skin; ctx.beginPath(); ctx.arc(18, -6, 3, 0, Math.PI*2); ctx.fill(); }
    // shield visual if equipped
    if(player.eq && player.eq.shield){ ctx.fillStyle='#89a'; ctx.beginPath(); ctx.arc(-16, -4, 8, 0, Math.PI*2); ctx.fill(); }
    ctx.restore();
    // Rim light
    ctx.globalAlpha=0.35; ctx.strokeStyle='#9cf'; ctx.beginPath(); ctx.arc(0,-24,8, -0.8, 0.3); ctx.stroke(); ctx.globalAlpha=1;
    ctx.restore();
    // Player nameplate above head
    ctx.save();
    ctx.textAlign='center'; ctx.textBaseline='alphabetic'; ctx.font='12px system-ui';
    ctx.strokeStyle='rgba(0,0,0,0.55)'; ctx.lineWidth=4; ctx.strokeText(player.name||'Rosarian', s.x, s.y-38);
    ctx.fillStyle='#e6f2ff'; ctx.fillText(player.name||'Rosarian', s.x, s.y-38);
    ctx.restore();
  }

  function drawMobSprite(m){
    const s=worldToScreen(m.x,m.y);
    // Dynamic ground shadow with height
    const z = (m.z||0);
    const shadowScale = Math.max(0.5, 1 - z/260);
    ctx.fillStyle='rgba(0,0,0,0.35)'; ctx.beginPath(); ctx.ellipse(s.x, s.y+m.r*0.4, m.r*0.8*shadowScale, m.r*0.4*shadowScale, 0, 0, Math.PI*2); ctx.fill();
    ctx.save(); if(m.hurt>0) ctx.globalAlpha = 0.7;
    if(m.type==='jelly'){
      const bodyColor = m.col || '#68c64f';
      const squ = (m.squash||0), str = (m.stretch||0);
      const sx = 1 + squ - str*0.4;
      const sy = 1 - squ + str*0.7;
      ctx.save();
      ctx.translate(0, -z*0.7);
      ctx.scale(sx, sy);
      const rx = m.r*0.95, ry = m.r*0.86;

      // limbs (subtle, drawn behind body)
      ctx.save();
      ctx.strokeStyle = '#efe6d6';
      ctx.lineWidth = 4; ctx.lineCap='round';
      ctx.beginPath();
      ctx.moveTo(s.x - rx*0.6, s.y+2); ctx.lineTo(s.x - rx*1.05, s.y+6); // left arm
      ctx.moveTo(s.x + rx*0.6, s.y+2); ctx.lineTo(s.x + rx*1.05, s.y+6); // right arm
      ctx.stroke();
      ctx.fillStyle = '#efe6d6';
      ctx.beginPath(); ctx.arc(s.x - rx*1.08, s.y+6, 4, 0, Math.PI*2); ctx.arc(s.x + rx*1.08, s.y+6, 4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse(s.x - rx*0.35, s.y + ry*0.95, 8, 5, 0, 0, Math.PI*2); ctx.ellipse(s.x + rx*0.35, s.y + ry*0.95, 8, 5, 0, 0, Math.PI*2); ctx.fill();
      ctx.restore();

      // body ‚Äî vertical bean with slight dent
      ctx.beginPath();
      ctx.ellipse(s.x-2, s.y-2, rx, ry*0.82, -0.12, 0.3, Math.PI*2);
      const g = ctx.createRadialGradient(s.x-10, s.y-12, 4, s.x+10, s.y+16, m.r+18);
      g.addColorStop(0, lighten(bodyColor, 0.22));
      g.addColorStop(0.45, bodyColor);
      g.addColorStop(1, shade(bodyColor, 0.62));
      ctx.fillStyle=g; ctx.fill();

      // headband
      ctx.fillStyle = '#b83a2c';
      ctx.fillRect(s.x-14, s.y-ry*0.9, 28, 5);
      ctx.fillStyle = '#e4b32a';
      ctx.beginPath(); ctx.arc(s.x, s.y-ry*0.9+2.5, 4.5, 0, Math.PI*2); ctx.fill();

      // gloss highlight
      const hl = ctx.createRadialGradient(s.x-12, s.y-14, 2, s.x-12, s.y-14, 18);
      hl.addColorStop(0,'rgba(255,255,255,0.85)'); hl.addColorStop(1,'rgba(255,255,255,0)');
      ctx.fillStyle=hl; ctx.beginPath(); ctx.ellipse(s.x-12, s.y-14, 12, 7, -0.5, 0, Math.PI*2); ctx.fill();

      // face
      ctx.fillStyle='white';
      ctx.beginPath(); ctx.arc(s.x-6, s.y-2, 3, 0, Math.PI*2); ctx.arc(s.x+6, s.y-2, 3, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#1a3d7a'; ctx.beginPath(); ctx.arc(s.x-6, s.y-2, 1.6, 0, Math.PI*2); ctx.arc(s.x+6, s.y-2, 1.6, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(0,40,20,0.85)'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(s.x-6, s.y+5); ctx.quadraticCurveTo(s.x, s.y+8, s.x+6, s.y+5); ctx.stroke();
      ctx.restore();
    }
    else if(m.type==='pumpkin'){ ctx.fillStyle='#ff9a35'; ctx.beginPath(); ctx.ellipse(s.x, s.y, m.r+2, m.r-2, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='#1e5d2a'; ctx.fillRect(s.x-2, s.y-m.r-6, 4, 8); ctx.strokeStyle='#b65a15'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(s.x-m.r*0.6, s.y); ctx.quadraticCurveTo(s.x, s.y+m.r*0.2, s.x+m.r*0.6, s.y); ctx.stroke(); }
    else if(m.type==='flanae'){ ctx.fillStyle='#8cd85a'; ctx.beginPath(); ctx.ellipse(s.x, s.y, m.r, m.r*0.6, 0, 0, Math.PI*2); ctx.fill(); ctx.fillStyle='rgba(200,255,220,0.6)'; ctx.beginPath(); ctx.ellipse(s.x-8, s.y-8, 14, 8, -0.6, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.ellipse(s.x-8, s.y+8, 14, 8, 0.6, 0, Math.PI*2); ctx.fill(); }
    else if(m.type==='jellyking'){
      // King Jelly Bean: reuse jelly look, scaled up, then add crown + ring
      const bodyColor = m.col || '#68c64f';
      const squ = (m.squash||0), str = (m.stretch||0);
      const sx = 1 + squ - str*0.4; const sy = 1 - squ + str*0.7;
      ctx.save(); ctx.translate(0, -(m.z||0)*0.7); ctx.scale(sx,sy);
      const rx = (m.r+16)*0.98, ry = (m.r+16)*0.9;
      // limbs
      ctx.save(); ctx.strokeStyle = '#efe6d6'; ctx.lineWidth = 6; ctx.lineCap='round';
      ctx.beginPath(); ctx.moveTo(s.x - rx*0.6, s.y+6); ctx.lineTo(s.x - rx*1.06, s.y+12);
      ctx.moveTo(s.x + rx*0.6, s.y+6); ctx.lineTo(s.x + rx*1.06, s.y+12); ctx.stroke(); ctx.restore();
      // body bean
      const g = ctx.createRadialGradient(s.x-14, s.y-18, 6, s.x+16, s.y+24, rx+26);
      g.addColorStop(0, lighten(bodyColor, 0.22)); g.addColorStop(0.45, bodyColor); g.addColorStop(1, shade(bodyColor, 0.62));
      ctx.fillStyle=g; ctx.beginPath(); ctx.ellipse(s.x-2, s.y, rx, ry*0.92, -0.12, 0, Math.PI*2); ctx.fill();
      // gloss
      const hl = ctx.createRadialGradient(s.x-18, s.y-22, 2, s.x-18, s.y-22, 26);
      hl.addColorStop(0,'rgba(255,255,255,0.9)'); hl.addColorStop(1,'rgba(255,255,255,0)');
      ctx.fillStyle=hl; ctx.beginPath(); ctx.ellipse(s.x-18, s.y-22, 18, 12, -0.5, 0, Math.PI*2); ctx.fill();
      // face
      ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(s.x-12, s.y-4, 4.6, 0, Math.PI*2); ctx.arc(s.x+12, s.y-4, 4.6, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#1a3d7a'; ctx.beginPath(); ctx.arc(s.x-12, s.y-4, 2.2, 0, Math.PI*2); ctx.arc(s.x+12, s.y-4, 2.2, 0, Math.PI*2); ctx.fill();
      ctx.strokeStyle='rgba(0,40,20,0.85)'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(s.x-12, s.y+10); ctx.quadraticCurveTo(s.x, s.y+14, s.x+12, s.y+10); ctx.stroke();
      // crown
      ctx.fillStyle='#ffd93b'; ctx.beginPath();
      ctx.moveTo(s.x-30, s.y-ry-18); ctx.lineTo(s.x-18, s.y-ry-2); ctx.lineTo(s.x-6, s.y-ry-18); ctx.lineTo(s.x+6, s.y-ry-2); ctx.lineTo(s.x+18, s.y-ry-18); ctx.lineTo(s.x+30, s.y-ry-2); ctx.lineTo(s.x+30, s.y-ry-18); ctx.lineTo(s.x-30, s.y-ry-18); ctx.fill();
      ctx.fillStyle='#6cf'; ctx.fillRect(s.x-14, s.y-ry-10, 6, 4); ctx.fillStyle='#9f5'; ctx.fillRect(s.x+8, s.y-ry-10, 6, 4);
      // floating ring
      ctx.strokeStyle='rgba(255,217,59,0.9)'; ctx.lineWidth=3; ctx.beginPath(); ctx.ellipse(s.x, s.y-ry-28, 28, 9, 0, 0, Math.PI*2); ctx.stroke();
      ctx.restore();
    }
    else if(m.type==='moldy'){ const g=ctx.createLinearGradient(0, s.y-m.r, 0, s.y+m.r); g.addColorStop(0,'#8dcf6a'); g.addColorStop(1,'#537a3d'); ctx.fillStyle=g; ctx.beginPath(); ctx.ellipse(s.x, s.y+4, m.r, m.r-4, 0, 0, Math.PI*2); ctx.fill(); }
    else if(m.type==='moldy_elite'){ const g=ctx.createLinearGradient(0, s.y-m.r, 0, s.y+m.r); g.addColorStop(0,'#79bf58'); g.addColorStop(1,'#3e6a2a'); ctx.fillStyle=g; ctx.beginPath(); ctx.ellipse(s.x, s.y+3, m.r+2, m.r-2, 0, 0, Math.PI*2); ctx.fill(); }
    else if(m.type==='rockgolem'){ ctx.fillStyle='#5b676f'; ctx.fillRect(s.x-m.r+2, s.y-m.r+6, (m.r*2)-4, (m.r*2)-10); ctx.fillStyle='#2a3238'; ctx.fillRect(s.x-6, s.y-4, 12, 8); }
    else if(m.type==='gorge_beetle'){
      // Gorge Beetle ‚Äî stout beetle with rocky carapace
      ctx.save();
      const r=m.r; ctx.translate(s.x,s.y);
      ctx.fillStyle='#5b4a2c'; ctx.beginPath(); ctx.ellipse(0, 4, r*1.1, r*0.8, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#2e2416'; ctx.beginPath(); ctx.ellipse(0, -4, r*0.8, r*0.6, 0, 0, Math.PI*2); ctx.fill();
      // legs
      ctx.strokeStyle='#2e2416'; ctx.lineWidth=3; ctx.beginPath(); ctx.moveTo(-r,0); ctx.lineTo(-r-6,6); ctx.moveTo(-r,4); ctx.lineTo(-r-6,10); ctx.moveTo(r,0); ctx.lineTo(r+6,6); ctx.moveTo(r,4); ctx.lineTo(r+6,10); ctx.stroke();
      // mandibles
      ctx.fillStyle='#cfc2a8'; ctx.fillRect(-4,-r*0.9,3,6); ctx.fillRect(1,-r*0.9,3,6);
      ctx.restore();
    }
    else if(m.type==='luna_wolf'){
      // Luna Wolf ‚Äî sleek icy wolf with glow eyes
      ctx.save(); const r=m.r; ctx.translate(s.x,s.y);
      ctx.fillStyle='#b8d4e8'; ctx.beginPath(); ctx.ellipse(0,4,r*1.2,r*0.7,0,0,Math.PI*2); ctx.fill();
      // head
      ctx.beginPath(); ctx.ellipse(r*0.8,-r*0.2,r*0.7,r*0.5,0,0,Math.PI*2); ctx.fill();
      // ear triangles
      ctx.beginPath(); ctx.moveTo(r*0.9,-r*0.9); ctx.lineTo(r*1.2,-r*0.4); ctx.lineTo(r*0.6,-r*0.5); ctx.closePath(); ctx.fill();
      // eyes
      ctx.fillStyle='#8fe0ff'; ctx.beginPath(); ctx.arc(r*1.1,-r*0.2,2.6,0,Math.PI*2); ctx.arc(r*0.9,-r*0.18,2.6,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
    else if(m.type==='luna_spirit'){
      // Luna Spirit ‚Äî floating wisp with cold aura
      ctx.save(); const r=m.r; ctx.translate(s.x,s.y);
      const grd = ctx.createRadialGradient(0,0,2,0,0,r+14);
      grd.addColorStop(0,'rgba(180,230,255,0.95)'); grd.addColorStop(1,'rgba(120,180,220,0.15)');
      ctx.fillStyle=grd; ctx.beginPath(); ctx.ellipse(0,0,r*0.9,r*0.9,0,0,Math.PI*2); ctx.fill();
      ctx.fillStyle='#dff6ff'; ctx.beginPath(); ctx.arc(-4,-2,3,0,Math.PI*2); ctx.arc(4,-2,3,0,Math.PI*2); ctx.fill();
      ctx.restore();
    }
    else if(m.type==='choropy'){
      // Choropy ‚Äî cute horizontal caterpillar with face leading
      ctx.save();
      const t = (performance.now? performance.now(): Date.now())*0.001;
      const wig = Math.sin(t*3 + (m.x+m.y)*0.01)*2;
      const dir = -1; // face on left side as requested (tail to the right)
      const headX = s.x; const headY = s.y + wig;
      const bodyGreen = '#6fd94e';
      const darkEdge  = '#3a742a';
      const belly     = '#f1e58a';
      // Draw segments from head to tail so tail follows behind
      const segs = 4; const gap = m.r*0.78;
      for(let i=0;i<segs;i++){
        const px = headX - i*gap*dir;
        const py = headY + Math.sin(t*3 + i*0.7)*1.8;
        const rr = i===0? m.r*0.95 : m.r*0.85;
        const g = ctx.createRadialGradient(px-8, py-8, 3, px+10, py+10, rr+16);
        g.addColorStop(0,'#baff7a'); g.addColorStop(0.5, bodyGreen); g.addColorStop(1,'#2c4d1f');
        ctx.fillStyle=g; ctx.strokeStyle=darkEdge; ctx.lineWidth=2;
        ctx.beginPath(); ctx.ellipse(px, py, rr, rr*0.72, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
        if(i===1){
          // belly oval and small forelimbs on second segment
          ctx.fillStyle=belly; ctx.strokeStyle=shade(belly,0.35); ctx.lineWidth=1.8;
          ctx.beginPath(); ctx.ellipse(px, py+rr*0.15, rr*0.6, rr*0.44, 0, 0, Math.PI*2); ctx.fill(); ctx.stroke();
          ctx.fillStyle=shade(belly,0.15);
          ctx.beginPath(); ctx.ellipse(px-rr*0.55, py+rr*0.05, 5, 3.6, 0.2, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.ellipse(px+rr*0.55, py+rr*0.05, 5, 3.6, -0.2, 0, Math.PI*2); ctx.fill();
        }
      }
      // Head details on first segment
      // antennae
      ctx.strokeStyle='#ffd24a'; ctx.lineWidth=4; ctx.lineCap='round';
      ctx.beginPath(); ctx.moveTo(headX-4, headY-m.r*0.8); ctx.quadraticCurveTo(headX-2, headY-m.r*1.2, headX-8, headY-m.r*1.5); ctx.stroke();
      ctx.beginPath(); ctx.moveTo(headX+4, headY-m.r*0.8); ctx.quadraticCurveTo(headX+6, headY-m.r*1.2, headX+12, headY-m.r*1.5); ctx.stroke();
      ctx.fillStyle='#ffef7a';
      ctx.beginPath(); ctx.rect(headX-10, headY-m.r*1.55, 6, 6); ctx.fill();
      ctx.beginPath(); ctx.rect(headX+8, headY-m.r*1.55, 6, 6); ctx.fill();
      // eyes
      // friendlier, cuter eyes (bigger whites, smaller pupils)
      ctx.fillStyle='white'; ctx.beginPath(); ctx.arc(headX-6, headY-3.8, 5.6, 0, Math.PI*2); ctx.arc(headX+6, headY-2.4, 5.6, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle='#2a3d2a'; ctx.beginPath(); ctx.arc(headX-6, headY-3.8, 1.6, 0, Math.PI*2); ctx.arc(headX+6, headY-2.4, 1.6, 0, Math.PI*2); ctx.fill();
      // smile
      ctx.strokeStyle='#2a3d2a'; ctx.lineWidth=2; ctx.beginPath(); ctx.moveTo(headX-8, headY+4); ctx.quadraticCurveTo(headX, headY+6.5, headX+8, headY+4); ctx.stroke();
      ctx.restore();
    }
    else if(m.type==='woopie'){
      // Woopie ‚Äî expressive chef-cat with apron and scarf
      const t = (performance.now? performance.now(): Date.now())*0.001;
      const bob = Math.sin(t*2.2 + (m.x+m.y)*0.02) * 1.2;
      const phase = ((m.x*37 + m.y*17) % 1000) * 0.001;
      const blinkOpen = (Math.sin(t*1.6 + phase) > 0.92) ? 0.18 : 1.0; // brief blink

      const r = m.r;
      const fur = '#c58a4a';
      const furShadow = '#a06a35';
      const innerEar = '#f3b3a1';
      const eye = '#3b2b1a';
      const scarf = '#d93a2e';
      const apron = '#f7f6f3';
      const apronShade = '#e9e6e0';

      ctx.save();
      ctx.translate(s.x, s.y + bob);

      // tail (drawn behind body)
      ctx.fillStyle = furShadow;
      ctx.beginPath();
      ctx.ellipse(-r*0.95, r*0.1, r*0.55, r*0.2, 0.25, 0, Math.PI*2);
      ctx.fill();

      // body
      ctx.fillStyle = fur;
      ctx.beginPath();
      ctx.ellipse(0, 4, r+2, r*0.9, 0, 0, Math.PI*2);
      ctx.fill();

      // arms/paws
      ctx.fillStyle = fur;
      ctx.beginPath(); ctx.ellipse(-r*0.88, 0, r*0.28, r*0.18, -0.4, 0, Math.PI*2); ctx.fill();
      ctx.beginPath(); ctx.ellipse( r*0.88, 0, r*0.28, r*0.18,  0.4, 0, Math.PI*2); ctx.fill();

      // apron with waist band and pocket
      ctx.fillStyle = apron; ctx.beginPath(); ctx.ellipse(0, 6, r*0.92, r*0.62, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = apronShade; ctx.fillRect(-r*0.48, 0, r*0.96, 8);
      ctx.fillStyle = apronShade; ctx.beginPath(); ctx.ellipse(0, 8, r*0.42, r*0.26, 0, 0, Math.PI*2); ctx.fill();

      // scarf/kerchief
      ctx.fillStyle = scarf;
      ctx.beginPath(); ctx.moveTo(-r*0.7, -r*0.15); ctx.lineTo(0, r*0.05); ctx.lineTo(r*0.7, -r*0.15); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo(-r*0.18, r*0.05); ctx.lineTo(0, r*0.38); ctx.lineTo(r*0.2, r*0.05); ctx.closePath(); ctx.fill();

      // head
      ctx.fillStyle = fur; ctx.beginPath(); ctx.ellipse(0, -r*0.25, r*0.98, r*0.78, 0, 0, Math.PI*2); ctx.fill();
      // ears
      ctx.fillStyle = furShadow; ctx.beginPath(); ctx.moveTo(-r*0.9, -r*0.95); ctx.lineTo(-r*0.45, -r*0.45); ctx.lineTo(-r*1.05, -r*0.45); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo( r*0.9, -r*0.95); ctx.lineTo( r*0.45, -r*0.45); ctx.lineTo( r*1.05, -r*0.45); ctx.closePath(); ctx.fill();
      ctx.fillStyle = innerEar; ctx.beginPath(); ctx.moveTo(-r*0.86, -r*0.82); ctx.lineTo(-r*0.56, -r*0.52); ctx.lineTo(-r*0.98, -r*0.52); ctx.closePath(); ctx.fill();
      ctx.beginPath(); ctx.moveTo( r*0.86, -r*0.82); ctx.lineTo( r*0.56, -r*0.52); ctx.lineTo( r*0.98, -r*0.52); ctx.closePath(); ctx.fill();

      // eyes (with blinking)
      const erx = r*0.22, ery = r*0.26*blinkOpen;
      ctx.fillStyle = 'white';
      ctx.beginPath(); ctx.ellipse(-r*0.34, -r*0.42, erx, ery, 0, 0, Math.PI*2); ctx.ellipse(r*0.34, -r*0.42, erx, ery, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = eye; ctx.beginPath(); ctx.arc(-r*0.34, -r*0.42, r*0.08, 0, Math.PI*2); ctx.arc(r*0.34, -r*0.42, r*0.08, 0, Math.PI*2); ctx.fill();

      // nose and mouth (open, happy)
      ctx.fillStyle = '#7a3b21'; ctx.beginPath(); ctx.ellipse(0, -r*0.35, r*0.08, r*0.06, 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#2a1512'; ctx.beginPath(); ctx.ellipse(0, -r*0.2, r*0.36, r*0.22*(0.9+Math.abs(bob)*0.06), 0, 0, Math.PI*2); ctx.fill();
      ctx.fillStyle = '#e87b78'; ctx.beginPath(); ctx.ellipse(0, -r*0.1, r*0.22, r*0.12, 0, 0, Math.PI*2); ctx.fill();

      // whiskers and blush
      ctx.strokeStyle = eye; ctx.lineWidth = 2; ctx.lineCap='round';
      ctx.beginPath(); ctx.moveTo(-r*0.24, -r*0.25); ctx.lineTo(-r*0.58, -r*0.32); ctx.moveTo(-r*0.24, -r*0.18); ctx.lineTo(-r*0.58, -r*0.18); ctx.moveTo(-r*0.24, -r*0.11); ctx.lineTo(-r*0.58, -r*0.04); ctx.stroke();
      ctx.beginPath(); ctx.moveTo( r*0.24, -r*0.25); ctx.lineTo( r*0.58, -r*0.32); ctx.moveTo( r*0.24, -r*0.18); ctx.lineTo( r*0.58, -r*0.18); ctx.moveTo( r*0.24, -r*0.11); ctx.lineTo( r*0.58, -r*0.04); ctx.stroke();
      ctx.fillStyle = 'rgba(255,122,122,0.35)'; ctx.beginPath(); ctx.ellipse(-r*0.6, -r*0.15, r*0.18, r*0.12, 0, 0, Math.PI*2); ctx.ellipse(r*0.6, -r*0.15, r*0.18, r*0.12, 0, 0, Math.PI*2); ctx.fill();

      // chef hat with red band
      ctx.fillStyle = '#e24b34'; ctx.fillRect(-r*0.32, -r*0.86, r*0.64, 6);
      ctx.fillStyle = '#f3f1ee';
      ctx.beginPath(); ctx.ellipse(0, -r*1.02, r*0.7, r*0.36, 0, 0, Math.PI*2); ctx.fill();

      ctx.restore();
    }
    ctx.fillStyle='rgba(0,0,0,.5)'; ctx.fillRect(s.x-18, s.y-m.r-12-(m.z||0)*0.4, 36, 5); ctx.fillStyle='#e55'; ctx.fillRect(s.x-18, s.y-m.r-12-(m.z||0)*0.4, 36*(m.hp/m.hpMax), 5);
    // Nameplate with difficulty color
    const mlv = getMobLevel(m); const diff = mlv - player.level; const di = getDiffInfo(diff);
    ctx.save(); ctx.textAlign='center'; ctx.textBaseline='alphabetic'; ctx.font='12px system-ui';
    ctx.fillStyle = di.color;
    const name = getMobName(m) + ' Lv' + mlv + ' ‚Äî ' + di.label;
    ctx.fillText(name, s.x, s.y - m.r - 18);
    ctx.restore();
    ctx.restore();
  }

  // NPC drawing
  function drawBadge(x,y,text,bg){ ctx.fillStyle=bg; ctx.beginPath(); ctx.arc(x,y,16,0,6.28); ctx.fill(); ctx.fillStyle='#fff'; ctx.font='14px system-ui'; ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillText(text,x,y+1); }
  function drawSign(n){ const s=worldToScreen(n.x,n.y); drawBadge(s.x,s.y,'‚ÑπÔ∏è','#3a4b5f'); }
  function drawMerchant(n){ const s=worldToScreen(n.x,n.y); drawBadge(s.x,s.y,'üõí','#3a5f3a'); }
  function drawTrainer(n){ const s=worldToScreen(n.x,n.y); drawBadge(s.x,s.y,'‚òÖ','#5b3a5f'); }
  function drawStorage(n){ const s=worldToScreen(n.x,n.y); drawBadge(s.x,s.y,'üß≥','#3a3f5f'); }
  function drawCartMaster(n){ const s=worldToScreen(n.x,n.y); drawBadge(s.x,s.y,'üõû','#5f4a2a'); }
  function drawCart(n){ const s=worldToScreen(n.x,n.y); ctx.fillStyle='#445'; ctx.fillRect(s.x-18,s.y-10,36,20); ctx.fillStyle='#ccc'; ctx.beginPath(); ctx.arc(s.x-10,s.y+12,6,0,6.28); ctx.arc(s.x+10,s.y+12,6,0,6.28); ctx.fill(); }

  // Difficulty nameplate helpers
  function getMobLevel(m){
    if(m.type==='jelly') return 2;
    if(m.type==='pumpkin') return 4;
    if(m.type==='flanae') return 5;
    if(m.type==='jellyking') return 12;
    if(m.type==='moldy') return 9;
    if(m.type==='moldy_elite') return 12;
    if(m.type==='rockgolem') return 16;
    if(m.type==='choropy') return 6;
    if(m.type==='woopie') return 8;
    if(m.type==='gorge_beetle') return 22;
    if(m.type==='luna_wolf') return 32;
    if(m.type==='luna_spirit') return 34;
    return m.boss? 14 : 6;
  }
  function getMobName(m){
    if(m.type==='jellyking') return 'Jelly Bean King';
    if(m.type==='flanae') return 'Flaenae';
    if(m.type==='choropy') return 'Choropy';
    if(m.type==='woopie') return 'Woopie';
    if(m.type==='gorge_beetle') return 'Gorge Beetle';
    if(m.type==='luna_wolf') return 'Luna Wolf';
    if(m.type==='luna_spirit') return 'Luna Spirit';
    const n = (m.type||'mob').replace(/_/g,' ').replace(/^./, c=>c.toUpperCase());
    if(n==='Jelly') return 'Jelly Bean';
    return n;
  }
  function getDiffInfo(diff){
    // Grey=unchallenging, green=easy, yellow=challenging, red=hard, purple=impossible
    if(diff<=-5) return {color:'#9aa3ad', label:'Unchallenging'};
    if(diff<=-2) return {color:'#71e6a2', label:'Easy'};
    if(Math.abs(diff)<=1) return {color:'#ffd24a', label:'Challenging'};
    if(diff<=6) return {color:'#ff6b6b', label:'Hard'};
    return {color:'#b077ff', label:'Impossible'};
  }

  // Start
  setSkillsForJob(player.job);
  loadStorage();
  showOverlay();
  tick();
})();
</script>
</body>
</html>
</html>